<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [tops-dev] [PATCH] Added leica tcr 705 sample data and	parser/exporter
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/tops-dev/2009-May/index.html" >
   <LINK REL="made" HREF="mailto:tops-dev%40lists.berlios.de?Subject=Re%3A%20%5Btops-dev%5D%20%5BPATCH%5D%20Added%20leica%20tcr%20705%20sample%20data%20and%0A%09parser/exporter&In-Reply-To=%3Cc1f853495d6589b03717.1241428303%40localhost.localdomain%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000006.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[tops-dev] [PATCH] Added leica tcr 705 sample data and	parser/exporter</H1>
    <B>Luca Bianconi</B> 
    <A HREF="mailto:tops-dev%40lists.berlios.de?Subject=Re%3A%20%5Btops-dev%5D%20%5BPATCH%5D%20Added%20leica%20tcr%20705%20sample%20data%20and%0A%09parser/exporter&In-Reply-To=%3Cc1f853495d6589b03717.1241428303%40localhost.localdomain%3E"
       TITLE="[tops-dev] [PATCH] Added leica tcr 705 sample data and	parser/exporter">luxetluc at yahoo.it
       </A><BR>
    <I>Mon May  4 11:11:43 CEST 2009</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000006.html">[tops-dev] [PATCH] Added leica tcr 705 sample data and	parser/exporter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7">[ date ]</a>
              <a href="thread.html#7">[ thread ]</a>
              <a href="subject.html#7">[ subject ]</a>
              <a href="author.html#7">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE># HG changeset patch
# User Luca Bianconi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">luxetluc at yahoo.it</A>&gt;
# Date 1237724319 -3600
# Node ID c1f853495d6589b03717f9bb57fa0ef6f8db48f1
# Parent  7dceb68353033fdeaf0f1e7240db7ed6a741a656
Added leica tcr 705 sample data and parser/exporter

diff -r 7dceb6835303 -r c1f853495d65 graphics/mat3d.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graphics/mat3d.py	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,899 @@
+&quot;&quot;&quot;OpenGL-based 3d surface plot&quot;&quot;&quot;
+#last updated 12/10/2006
+from OpenGL.GL import *
+from OpenGL.GLUT import *
+from OpenGL.Tk import *
+
+import numpy as N
+import tkFileDialog
+# global constants
+Colors = N.array([[201.0, 172.0,86.0],[201.0, 115.0,86.0],[201.0,86.0,89.0],
+                [201.0, 86.0,172.0],[172.0, 86.0,201.0],[115.0, 86.0,201.0],
+                  [86.0,115.0,201.0],[86.0, 172.0,201.0],[86.0, 201.0,172.0],
+                  [86.0,201.0,115.0],[115.0, 201.0,86.0],[172.0, 201.0,86.0]])/256
+
+glutInit(sys.argv)
+                  
+class figure :
+    
+    def __init__(self):
+        return
+
+    def PutText3d(self,x,y,z,text) :
+        &quot;&quot;&quot; Draws text (using GLUT package) at given x,y,z coordinates&quot;&quot;&quot;
+        glRasterPos3f(x,y,z)
+        for i in range(len(text)) :
+            glutBitmapCharacter(GLUT_BITMAP_8_BY_13, ord(text[i]));
+  
+    def SetColor(self,height) :
+        &quot;&quot;&quot; Sets the colour from the colour index according to the plot height&quot;&quot;&quot;
+        color_index = int(round((height)*11))
+        glColor3f(self.Colors[color_index,0],self.Colors[color_index,1],
+        self.Colors[color_index,2])
+
+    def Rescale(self,X,Y,Z) :
+        &quot;&quot;&quot;Scales values from 0 to 1&quot;&quot;&quot;
+        
+        X,Y,Z = map(N.asarray,(X,Y,Z))
+        
+	self.xmin = X.min()
+        self.xmax = X.max()
+        self.ymin = Y.min()
+        self.ymax = Y.max()
+        self.zmin = Z.min()
+        self.zmax = Z.max()
+
+	#rescaling
+        if self.xmax==self.xmin :
+            xdif = 0.01
+        else:
+            xdif = abs(self.xmax-self.xmin)
+
+        if self.ymax==self.ymin :
+            ydif = 0.01
+        else:
+            ydif = abs(self.ymax-self.ymin)
+
+        if self.zmax==self.zmin :
+            zdif = 0.01
+        else:
+            zdif = abs(self.zmax-self.zmin)
+	#rescaling
+        self.X = (X-self.xmin)/xdif
+        self.Y = (Y-self.ymin)/ydif
+        self.Z = (Z-self.zmin)/zdif
+
+
+    def InitGfx(self) :
+        glShadeModel(GL_SMOOTH)
+        glClearColor(1, 1, 1, 1)
+        glClearDepth(1.0)					# Enables Clearing Of The Depth Buffer
+        for option in [GL_DEPTH_TEST,GL_LINE_SMOOTH,GL_POINT_SMOOTH, \
+                       GL_POLYGON_SMOOTH,GL_BLEND]:
+            glEnable(option)
+            
+        glDepthFunc(GL_LEQUAL);
+        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA)
+        
+        for hint in [GL_PERSPECTIVE_CORRECTION_HINT,GL_LINE_SMOOTH_HINT, \
+                     GL_POLYGON_SMOOTH_HINT]:
+            glHint(hint,GL_NICEST)
+            
+        glClearColor(1, 1, 1, 0)    
+        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
+        glColor3f(1.0, 0.0, 1.0)
+        glMatrixMode(GL_MODELVIEW)    
+
+    def DrawPlotBox(self) :
+        &quot;&quot;&quot; Draws 3 faces of a box that will contain our plot&quot;&quot;&quot;
+        modelview = glGetDoublev(GL_MODELVIEW_MATRIX)
+        modelview = N.array(modelview)
+	t_model = modelview.transpose()
+        inv_modelview = N.linalg.inv(t_model)
+        self.inv_mv = inv_modelview
+        eye = N.array([0,0,-1,1])
+        view = N.dot(inv_modelview,eye)
+        view = view/float(view[3])
+        view = view[0:3]  
+        self.view = view
+        init_x = N.array([1,0,0,1])
+        new_x = N.dot(inv_modelview,init_x)
+        new_x = new_x/float(new_x[3])
+        new_x= new_x[0:3] 
+        self.new_x = new_x
+        init_y = N.array([0,1,0,1])
+        new_y = N.dot(inv_modelview,init_y)
+        new_y = new_y/float(new_y[3])
+        new_y= new_y[0:3]
+        self.new_y = new_y
+
+        offset = self.offset
+        
+        glColor3f(0.98, 0.98, 0.98)
+        glDisable(GL_LIGHTING)
+        glPolygonMode(GL_FRONT_AND_BACK,GL_FILL)
+        glBegin(GL_QUADS) #x,z,y
+        
+        if N.dot(view,[1,0,0]) &lt; 0 :
+            glVertex3f(0-0.5-offset ,0-0.5-offset ,0-0.5-offset )       #1
+            glVertex3f(0-0.5-offset ,1-0.5+offset,0-0.5-offset )
+            glVertex3f(0-0.5-offset ,1-0.5+offset,1-0.5+offset  )
+            glVertex3f(0-0.5-offset ,0-0.5-offset ,1-0.5+offset  )
+            self.sides = [1]
+        else :  
+            glVertex3f(1-0.5+offset  ,0-0.5-offset ,0-0.5-offset )               #2
+            glVertex3f(1-0.5+offset   ,0-0.5-offset ,1-0.5+offset )
+            glVertex3f(1-0.5+offset,1-0.5+offset ,1-0.5+offset )
+            glVertex3f(1-0.5+offset  ,1-0.5+offset  ,0-0.5-offset )
+            self.sides = [2]
+
+        if N.dot(view,[0,1,0]) &lt; 0 :
+
+            glVertex3f(0-0.5-offset,0-0.5-offset,0-0.5-offset)       #3
+            glVertex3f(0-0.5-offset,0-0.5-offset,1-0.5+offset)
+            glVertex3f(1-0.5+offset ,0-0.5-offset,1-0.5+offset)
+            glVertex3f(1-0.5+offset,0-0.5-offset ,0-0.5-offset )
+            self.sides.append(3)
+        else :
+            glVertex3f(0-0.5-offset ,1-0.5+offset ,0-0.5-offset )    #4
+            glVertex3f(1-0.5+offset ,1-0.5+offset ,0-0.5-offset )
+            glVertex3f(1-0.5+offset,1-0.5+offset ,1-0.5+offset )
+            glVertex3f(0-0.5-offset ,1-0.5+offset,1-0.5+offset)
+            self.sides.append(4)
+
+        if N.dot(view,[0,0,1]) &gt; 0 :
+            glVertex3f(0-0.5-offset ,0-0.5-offset ,1-0.5+offset)               #6
+            glVertex3f(0-0.5-offset ,1-0.5+offset,1-0.5+offset )
+            glVertex3f(1-0.5+offset,1-0.5+offset,1-0.5+offset)
+            glVertex3f(1-0.5+offset,0-0.5-offset ,1-0.5+offset)
+            self.sides.append(6)
+        else : 
+            glVertex3f(0-0.5-offset,0-0.5-offset ,0-0.5-offset )    #5
+            glVertex3f(1-0.5+offset,0-0.5-offset ,0-0.5-offset )
+            glVertex3f(1-0.5+offset,1-0.5+offset,0-0.5-offset )
+            glVertex3f(0-0.5-offset ,1-0.5+offset,0-0.5-offset )
+            self.sides.append(5)         
+        glEnd()
+        glEnable(GL_LIGHTING)
+
+    def DrawPlotBoxLines(self):
+        &quot;&quot;&quot; Draws lines on the plot box&quot;&quot;&quot;
+        glDisable(GL_LIGHTING)
+        #glEnable(GL_LINE_STIPPLE)
+        #glLineStipple(2,43690)
+        glColor3f(0.9,0.9,0.9)
+        offset = self.offset
+        glBegin(GL_LINES)
+        for a in range(1,4):
+
+            if self.sides[0] == 2:
+                glVertex3f(1-0.5+offset,0-0.5+0.25*a,1-0.5+offset   )
+                glVertex3f(1-0.5+offset,0-0.5+0.25*a,0-0.5-offset )               #2
+        
+                glVertex3f(1-0.5+offset,1-0.5+offset,0-0.5+0.25*a)
+                glVertex3f(1-0.5+offset,0-0.5-offset,0-0.5+0.25*a)               #2
+            else :
+                glVertex3f(0-0.5-offset,0-0.5+0.25*a,1-0.5+offset)
+                glVertex3f(0-0.5-offset,0-0.5+0.25*a,0-0.5-offset)               #1
+        
+                glVertex3f(0-0.5-offset,1-0.5+offset,0-0.5+0.25*a)
+                glVertex3f(0-0.5-offset,0-0.5-offset,0-0.5+0.25*a)               #1
+                
+            if self.sides[1] == 3:
+                glVertex3f(0-0.5+0.25*a,0-0.5-offset,1-0.5+offset)
+                glVertex3f(0-0.5+0.25*a,0-0.5-offset,0-0.5-offset)       #3
+            
+                glVertex3f(1-0.5+offset,0-0.5-offset,0-0.5+0.25*a)
+                glVertex3f(0-0.5-offset,0-0.5-offset,0-0.5+0.25*a)       #3
+            else :
+                glVertex3f(0-0.5+0.25*a,1-0.5+offset,1-0.5+offset)
+                glVertex3f(0-0.5+0.25*a,1-0.5+offset,0-0.5-offset)       #4
+            
+                glVertex3f(1-0.5+offset,1-0.5+offset,0-0.5+0.25*a)
+                glVertex3f(0-0.5-offset,1-0.5+offset,0-0.5+0.25*a) 
+                
+            if self.sides[2] == 5:
+                glVertex3f(1-0.5+offset,0-0.5+0.25*a,0-0.5-offset)
+                glVertex3f(0-0.5-offset,0-0.5+0.25*a,0-0.5-offset)    #5
+            
+                glVertex3f(0-0.5+0.25*a,1-0.5+offset,0-0.5-offset)
+                glVertex3f(0-0.5+0.25*a,0-0.5-offset,0-0.5-offset) #5
+            else :
+                glVertex3f(1-0.5+offset,0-0.5+0.25*a,1-0.5+offset)
+                glVertex3f(0-0.5-offset,0-0.5+0.25*a,1-0.5+offset)    #6
+            
+                glVertex3f(0-0.5+0.25*a,1-0.5+offset,1-0.5+offset)
+                glVertex3f(0-0.5+0.25*a,0-0.5-offset,1-0.5+offset) #6      
+        glEnd()
+        #glDisable(GL_LINE_STIPPLE)
+        glColor3f(0,0,0)
+        glEnable(GL_LIGHTING)
+
+    def GetFormatMaxTextLength(self) :
+        import decimal as D 
+        D.getcontext().prec = self.precision
+        ticks = []
+        xticks = []
+        yticks = []
+        zticks = []
+
+        for a in range(self.num_ticks):
+            numberx = self.xmin +a*0.25*(self.xmax-self.xmin)
+            numbery = self.ymin +a*0.25*(self.ymax-self.ymin)
+            numberz = self.zmin +a*0.25*(self.zmax-self.zmin)
+            strnumberx = str(D.Decimal(str(numberx))+0) 
+            strnumbery = str(D.Decimal(str(numbery))+0)
+            strnumberz = str(D.Decimal(str(numberz))+0)
+            if ((strnumberx[0:3]=='0.0') or (strnumberx[0:4]=='-0.0')) and float(strnumberx)!=0:
+                strnumberx = '%.*e' % (self.precision-1,float(strnumberx))
+            if ((strnumbery[0:3]=='0.0') or (strnumbery[0:4]=='-0.0'))and float(strnumbery)!=0:
+                strnumbery = '%.*e' % (self.precision-1,float(strnumbery))
+            if ((strnumberz[0:3]=='0.0') or (strnumberz[0:4]=='-0.0'))and float(strnumberz)!=0:
+                strnumberz = '%.*e' % (self.precision-1,float(strnumberz))
+            xticks.append(strnumberx)
+            yticks.append(strnumbery)
+            zticks.append(strnumberz)
+            ticks.append(len(strnumberx))
+            ticks.append(len(strnumbery))
+            ticks.append(len(strnumberz))
+
+        return max(ticks), xticks,yticks,zticks
+        
+
+    def InsertAxesText(self) :
+        &quot;&quot;&quot; Identifies on which sides axis should be drawn, establishes the orientation
+            of the text in relation to the plot area and draws the text accordingly. &quot;&quot;&quot;
+        glDisable(GL_LIGHTING)
+        glMatrixMode(GL_MODELVIEW);
+        glLineWidth(2.0)
+        textlength,xticks,yticks,zticks = self.textlength,self.xticks,self.yticks,self.zticks
+        base_left_offset = 0.03
+        ax_base_left_offset =0.08
+        top_up_offset = -0.025
+        bottom_up_offset = 0.05
+        ax_top_up_offset = -0.075
+        ax_bottom_up_offset = 0.1
+        textoffset = 0.025
+        ticksoffset = 1/float(self.num_ticks-1)
+        if abs(N.dot([1,0,0],self.view)) &lt; abs(N.dot([0,1,0],self.view)):
+            point = N.array([self.sides[0]-1.5,3.5-self.sides[1],0])
+            line = N.array([0,0,1])
+            if abs(self.new_x[0]) &gt; abs(self.new_x[1]) :
+                if point[0]*self.new_x[0] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            else :
+                if point[1]*self.new_x[1] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            if abs(self.new_y[0]) &gt; abs(self.new_y[1]) :
+                if point[0]*self.new_y[0] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset  = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset  = ax_bottom_up_offset
+            else :
+                if point[1]*self.new_y[1] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset  = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset  = ax_bottom_up_offset
+            if (abs(N.dot(line,self.new_x)) &gt; 0.4) and(abs(N.dot(line,self.new_y)) &gt; 0.21) :
+                factor = 1
+            else :
+                factor = 1.2*(1-abs(N.dot(line,self.new_x)))
+            factor2 = 1.2*(1-abs(N.dot(line,self.new_y)))
+            offset = left_offset*factor*self.new_x + up_offset*factor2*self.new_y
+            ax_offset = ax_left_offset*factor*self.new_x+ax_up_offset*factor2*self.new_y
+    
+            for a in range(self.num_ticks):
+                self.PutText3d(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0)-offset[0],3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0)-offset[1],-0.5 + a*ticksoffset-offset[2],yticks[a])        
+            self.PutText3d(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0)-ax_offset[0],3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0)-ax_offset[1],0-ax_offset[2],'Y')
+
+            glBegin(GL_LINES)
+            glVertex3f(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0),3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0),-0.5-self.offset)
+            glVertex3f(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0),3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0),0.5+self.offset)
+            for a in range(self.num_ticks):
+                glVertex3f(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0),3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0)+0.025*cmp(3.5-self.sides[1],0),-0.5+a*ticksoffset)
+                glVertex3f(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0),3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0),-0.5+a*ticksoffset)
+            
+        else :
+            point = N.array([1.5-self.sides[0],self.sides[1]-3.5,0])
+            if abs(self.new_x[0]) &gt; abs(self.new_x[1]) :
+                if point[0]*self.new_x[0] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            else :
+                if point[1]*self.new_x[1] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            if abs(self.new_y[0]) &gt; abs(self.new_y[1]) :
+                if point[0]*self.new_y[0] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset = ax_bottom_up_offset
+            else :
+                if point[1]*self.new_y[1] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset  = ax_bottom_up_offset
+            line = N.array([0,0,1])
+            if (abs(N.dot(line,self.new_x)) &gt; 0.4) and (abs(N.dot(line,self.new_y)) &gt; 0.21) :
+                factor = 1
+            else :
+                factor = 1.2*(1-abs(N.dot(line,self.new_x)))
+            factor2 = 1.2*(1-abs(N.dot(line,self.new_y)))
+            offset = left_offset*factor*self.new_x
+            offset = offset + up_offset*factor2*self.new_y
+            ax_offset = ax_left_offset*factor*self.new_x+ax_up_offset*factor2*self.new_y
+            for a in range(self.num_ticks) :
+                self.PutText3d(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0)-offset[0],self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0)-offset[1],-0.5+a*ticksoffset-offset[2],yticks[a])
+            self.PutText3d(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0)-ax_offset[0],self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0)-ax_offset[1],0-ax_offset[2],'Y')
+
+            glBegin(GL_LINES)
+            glVertex3f(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0),self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0),-0.5-self.offset)
+            glVertex3f(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0),self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0),0.5+self.offset)
+            for a in range(self.num_ticks):
+                glVertex3f(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0)+0.025*cmp(1.5-self.sides[0],0),self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0),-0.5+ticksoffset*a)
+                glVertex3f(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0),self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0),-0.5+ticksoffset*a)
+        glEnd()
+
+         #-------------------------------------------------
+        if abs(N.dot([1,0,0],self.view)) &lt; abs(N.dot([0,0,1],self.view)):
+            glBegin(GL_LINES) 
+            glVertex3f(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0),-0.5-self.offset,5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0))
+            glVertex3f(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0),0.5+self.offset,5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0))
+            for a in range(self.num_ticks):
+                glVertex3f(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0),-0.5+ticksoffset*a,5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0)+0.025*cmp(5.5-self.sides[2],0))
+                glVertex3f(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0),-0.5+ticksoffset*a,5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0))
+            glEnd() 
+            point = N.array([self.sides[0]-1.5,0,5.5-self.sides[2]])
+            if abs(self.new_x[0]) &gt; abs(self.new_x[2]) :
+                if point[0]*self.new_x[0] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            else :
+                if point[2]*self.new_x[2] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            if abs(self.new_y[0]) &gt; abs(self.new_y[2]) :
+                if point[0]*self.new_y[0] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset  = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset  = ax_bottom_up_offset
+            else :
+                if point[2]*self.new_y[2] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset  = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset  = ax_bottom_up_offset
+            line = N.array([0,1,0])
+            if (abs(N.dot(line ,self.new_x)) &gt; 0.4) and (abs(N.dot(line ,self.new_y)) &gt; 0.21) :
+                factor = 1
+            else :
+                factor = 1.2*(1-abs(N.dot(line ,self.new_x)))
+            factor2 = 1.2*(1-abs(N.dot(line ,self.new_y)))
+            offset = left_offset*factor*self.new_x
+            offset = offset + up_offset*factor2*self.new_y 
+            ax_offset = ax_left_offset*factor*self.new_x+ax_up_offset*factor2*self.new_y
+            for a in range(self.num_ticks):
+                self.PutText3d(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0)-offset[0],-0.5+ticksoffset*a-offset[1],5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0)-offset[2],zticks[a])          
+            self.PutText3d(self.sides[0]-1.5+self.offset*cmp(self.sides[0]-1.5,0)-ax_offset[0],0-ax_offset[1],5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0)-ax_offset[2],'Z')
+
+        else :
+            glBegin(GL_LINES) 
+            glVertex3f(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0),-0.5-self.offset,self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0))
+            glVertex3f(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0),0.5+self.offset,self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0))
+            for a in range(self.num_ticks):
+                glVertex3f(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0)+0.025*cmp(1.5-self.sides[0],0),-0.5+ticksoffset*a,self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0))
+                glVertex3f(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0),-0.5+ticksoffset*a,self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0))
+            glEnd()
+            point = N.array([1.5-self.sides[0],0,self.sides[2]-5.5])
+            if abs(self.new_x[0]) &gt; abs(self.new_x[2]) :
+                if point[0]*self.new_x[0] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            else :
+                if point[2]*self.new_x[2] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            if abs(self.new_y[0]) &gt; abs(self.new_y[2]) :
+                if point[0]*self.new_y[0] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset  = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset  = ax_bottom_up_offset
+            else :
+                if point[2]*self.new_y[2] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset  = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset  = ax_bottom_up_offset
+            line = N.array([0,1,0])
+            if (abs(N.dot(line,self.new_x)) &gt; 0.4) and (abs(N.dot(line,self.new_y)) &gt; 0.21) :
+                factor = 1
+            else :
+                factor = 1.2*(1-abs(N.dot(line,self.new_x)))
+            factor2 = 1.2*(1-abs(N.dot(line,self.new_y)))
+            offset = left_offset*factor*self.new_x
+            offset = offset + up_offset*factor2*self.new_y
+            ax_offset = ax_left_offset*factor*self.new_x+ax_up_offset*factor2*self.new_y
+            for a in range(self.num_ticks):
+                self.PutText3d(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0)-offset[0],-0.5+ticksoffset*a-offset[1],self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0)-offset[2],zticks[a])
+            self.PutText3d(1.5-self.sides[0]+self.offset*cmp(1.5-self.sides[0],0)-ax_offset[0],0-ax_offset[1],self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0)-ax_offset[2],'Z')
+
+        #------------------------------------------------------------
+        if abs(N.dot([0,1,0],self.view)) &lt; abs(N.dot([0,0,1],self.view)):
+            glBegin(GL_LINES) 
+            glVertex3f(-0.5-self.offset,self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0),5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0))
+            glVertex3f(0.5+self.offset,self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0),5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0))
+            for a in range(self.num_ticks):
+                glVertex3f(-0.5+ticksoffset*a,self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0),5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0)+0.025*cmp(5.5-self.sides[2],0))
+                glVertex3f(-0.5+ticksoffset*a,self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0),5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0))
+            glEnd()
+            point = N.array([0,self.sides[1]-3.5,5.5-self.sides[2]])
+            if abs(self.new_x[1]) &gt; abs(self.new_x[2]) :
+                if point[1]*self.new_x[1] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            else :
+                if point[2]*self.new_x[2] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            if abs(self.new_y[1]) &gt; abs(self.new_y[2]) :
+                if point[1]*self.new_y[1] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset  = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset  = ax_bottom_up_offset
+            else :
+                if point[2]*self.new_y[2] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset  = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset  = ax_bottom_up_offset
+            line = N.array([1,0,0])
+            if (abs(N.dot(line,self.new_x)) &gt; 0.4) and (abs(N.dot(line,self.new_y)) &gt; 0.21) :
+                factor = 1
+            else :
+                factor = 1.2*(1-abs(N.dot(line,self.new_x)))
+            factor2 = 1.2*(1-abs(N.dot(line,self.new_y)))
+            offset = left_offset*factor*self.new_x
+            offset = offset + up_offset*factor2*self.new_y
+            ax_offset = ax_left_offset*factor*self.new_x+ax_up_offset*factor2*self.new_y
+            for a in range(self.num_ticks):
+                self.PutText3d(-0.5+ticksoffset*a-offset[0],self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0)-offset[1],5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0)-offset[2],xticks[a])
+            self.PutText3d(0-ax_offset[0],self.sides[1]-3.5+self.offset*cmp(self.sides[1]-3.5,0)-ax_offset[1],5.5-self.sides[2]+self.offset*cmp(5.5-self.sides[2],0)-ax_offset[2],'X')
+
+        else :
+            glBegin(GL_LINES) 
+            glVertex3f(-0.5-self.offset,3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0),self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0))
+            glVertex3f(0.5+self.offset,3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0),self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0))
+            for a in range(self.num_ticks):
+                glVertex3f(-0.5+ticksoffset*a,3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0)+0.025*cmp(3.5-self.sides[1],0),self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0))
+                glVertex3f(-0.5+ticksoffset*a,3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0),self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0))
+            glEnd()
+            point = N.array([0,3.5-self.sides[1],self.sides[2]-5.5])
+            if abs(self.new_x[1]) &gt; abs(self.new_x[2]) :
+                if point[1]*self.new_x[1] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            else :
+                if point[2]*self.new_x[2] &gt; 0 :
+                    #right
+                    left_offset = -base_left_offset
+                    ax_left_offset = -ax_base_left_offset-textlength*textoffset
+                else :
+                    #left
+                    left_offset = base_left_offset +textlength*textoffset
+                    ax_left_offset = ax_base_left_offset+(textlength+1)*textoffset
+            if abs(self.new_y[1]) &gt; abs(self.new_y[2]) :
+                if point[1]*self.new_y[1] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset  = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset  = ax_bottom_up_offset
+            else :
+                if point[2]*self.new_y[2] &gt; 0 :
+                    #top
+                    up_offset = top_up_offset
+                    ax_up_offset  = ax_top_up_offset
+                else :
+                    #bottom
+                    up_offset = bottom_up_offset
+                    ax_up_offset  = ax_bottom_up_offset
+            line = N.array([1,0,0])
+            if (abs(N.dot(line,self.new_x)) &gt; 0.4) and (abs(N.dot(line,self.new_y)) &gt; 0.21) :
+                factor = 1
+            else :
+                factor = 1.2*(1-abs(N.dot(line,self.new_x)))
+            factor2 = 1.2*(1-abs(N.dot(line,self.new_y)))
+            offset = left_offset*factor*self.new_x
+            offset = offset + up_offset*factor2*self.new_y
+            ax_offset = ax_left_offset*factor*self.new_x+ax_up_offset*factor2*self.new_y
+            for a in range(self.num_ticks):
+                self.PutText3d(-0.5+ticksoffset*a-offset[0],3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0)-offset[1],self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0)-offset[2],xticks[a])       
+            self.PutText3d(0-ax_offset[0],3.5-self.sides[1]+self.offset*cmp(3.5-self.sides[1],0)-ax_offset[1],self.sides[2]-5.5+self.offset*cmp(self.sides[2]-5.5,0)-ax_offset[2],'X')
+       
+        glLineWidth(self.linewidth)
+        glColor3f(0.0,0.0,0.0)
+        glEnable(GL_LIGHTING)
+        
+    def redraw(self,o):
+        self.InitGfx()
+        self.DrawPlotBox()
+        self.DrawPlotBoxLines()
+        
+        glLineWidth(self.linewidth)
+        self.InsertAxesText()
+        self.drawplot()
+        glLineWidth(0.1)
+
+    def save(self):
+        myFormats = [
+            ('Windows Bitmap','*.bmp'),
+            ('Enhanced Windows Metafile','*.emf'),
+            ('Encapsulated PostScript','*.eps'),
+            ('CompuServe GIF','*.gif'),
+            ('JPEG / JPG','*.jpg'),
+            ('Zsoft Paintbrush','*.pcx'),
+            ('Portable Network Graphics','*.png'),
+            ('Portable Pixelmap','*.ppm'),
+            ('Tagged Image File Format','*.tif'),
+            ]
+        fileName = tkFileDialog.asksaveasfilename(filetypes=myFormats ,title=&quot;Save the image as...&quot;)
+        if fileName :
+            self.SaveTo(fileName)
+	
+    def SaveTo(self,filename):
+	&quot;&quot;&quot;Save current buffer to filename in format&quot;&quot;&quot;
+	import Image # get PIL's functionality...
+	viewport = glGetIntegerv(GL_VIEWPORT)
+	width, height = viewport[2],viewport[3]
+	glPixelStorei(GL_PACK_ALIGNMENT, 1)
+	data = glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE)
+	image = Image.fromstring( &quot;RGB&quot;, (width, height), data )
+	image = image.transpose( Image.FLIP_TOP_BOTTOM)
+	image.save( filename)
+	print 'Saved image to %s'% (os.path.abspath( filename))
+	return image
+            
+    def make_plot(self,colors = Colors):
+        &quot;&quot;&quot;Draw a plot in a Tk OpenGL render window.&quot;&quot;&quot;
+        
+        # Some api in the chain is translating the keystrokes to this octal string
+        # so instead of saying: ESCAPE = 27, we use the following.
+        ESCAPE = '\033'
+
+        # Number of the glut window.
+        window = 0
+        
+        # Create render window (tk)
+        f = Frame()
+  	f.pack(side = 'top')
+  	self.offset = 0.05
+  	self.textlength,self.xticks,self.yticks,self.zticks =self.GetFormatMaxTextLength() #todo: each tick own offset
+  	o = Opengl(width = 640, height = 480, double = 1, depth = 1)
+  	o.redraw = self.redraw
+  	quit = Button(f, text = 'Quit', command = sys.exit)
+  	quit.pack({'side':'top', 'side':'left'})
+  	help = Button(f, text = 'Help', command = o.help)
+  	help.pack({'side':'top', 'side':'left'})
+  	save = Button(f, text = 'Save', command = self.save)
+  	save.pack({'side':'top', 'side':'left'})
+  	reset = Button(f, text = 'Reset', command = o.reset)
+  	reset.pack({'side':'top', 'side':'left'})
+  	o.pack(side = 'top', expand = 1, fill = 'both')
+  	o.set_background(1,1,1)
+        o.set_centerpoint(0.0, 0.0, 0.0)
+        o.set_eyepoint(3)
+        o.autospin = 1
+  	o.mainloop()
+
+
+class mesh(figure) :
+    &quot;&quot;&quot;class for surface meshes&quot;&quot;&quot;
+    def __init__(self,X,Y,Z,colors = Colors,linewidth = 0.1,fill_mesh = 0,precision=3,num_ticks=5):
+        self.Colors = colors
+        self.linewidth= linewidth
+        self.fill_mesh = fill_mesh
+        self.precision = precision
+        self.num_ticks = num_ticks
+        self.Rescale(X,Y,Z)
+        self.make_plot(colors)
+        return
+
+    def drawplot(self) :
+        glDisable(GL_LIGHTING)
+
+        X_shift = self.X-0.5
+        Y_shift = self.Y-0.5
+        Z_shift = self.Z-0.5
+        
+        plotsizex,plotsizey = N.shape(self.X)
+
+        if self.fill_mesh :
+            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+	    glEnable(GL_POLYGON_OFFSET_FILL);
+            glPolygonOffset(1.0, 1.0);
+            glColor3f(0.98, 0.98, 0.98)
+            glBegin(GL_TRIANGLES)
+            for i in range(plotsizex-1):
+                for j in range(plotsizey-1):
+                    self.SetColor(self.Z[i,j])
+                    glVertex3f( X_shift[i,j],Z_shift[i,j],Y_shift[i,j])
+                    self.SetColor(self.Z[i,j])
+                    glVertex3f( X_shift[i+1,j],Z_shift[i+1,j],Y_shift[i+1,j])
+                    self.SetColor(self.Z[i,j])
+                    glVertex3f( X_shift[i,j+1], Z_shift[i,j+1],Y_shift[i,j+1] )
+                    self.SetColor(self.Z[i+1,j])
+                    glVertex3f( X_shift[i+1,j], Z_shift[i+1,j],Y_shift[i+1,j] )
+                    self.SetColor(self.Z[i,j+1])
+                    glVertex3f( X_shift[i,j+1], Z_shift[i,j+1],Y_shift[i,j+1])
+                    self.SetColor(self.Z[i+1,j+1])
+                    glVertex3f( X_shift[i+1,j+1], Z_shift[i+1,j+1],Y_shift[i+1,j+1] )
+            glEnd()
+            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+            glColor3f(0.0, 0.0, 0.0)
+            glBegin(GL_TRIANGLES)
+            for i in range(plotsizex-1):
+                for j in range(plotsizey-1):
+                    glVertex3f( X_shift[i,j],Z_shift[i,j],Y_shift[i,j])
+                    glVertex3f( X_shift[i+1,j],Z_shift[i+1,j],Y_shift[i+1,j])
+                    glVertex3f( X_shift[i,j+1], Z_shift[i,j+1],Y_shift[i,j+1] )
+                    glVertex3f( X_shift[i+1,j], Z_shift[i+1,j],Y_shift[i+1,j] )
+                    glVertex3f( X_shift[i,j+1], Z_shift[i,j+1],Y_shift[i,j+1])
+                    glVertex3f( X_shift[i+1,j+1], Z_shift[i+1,j+1],Y_shift[i+1,j+1] )
+            glEnd()
+        else :
+            #Simple hidden surface removal
+            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+            glColor3f(0.0, 0.0, 0.0)
+            glBegin(GL_TRIANGLES)
+            for i in range(plotsizex-1):
+                for j in range(plotsizey-1):
+                    self.SetColor(self.Z[i,j])
+                    glVertex3f( X_shift[i,j],Z_shift[i,j],Y_shift[i,j])
+                    self.SetColor(self.Z[i+1,j])
+                    glVertex3f( X_shift[i+1,j],Z_shift[i+1,j],Y_shift[i+1,j])
+                    self.SetColor(self.Z[i,j+1])
+                    glVertex3f( X_shift[i,j+1], Z_shift[i,j+1],Y_shift[i,j+1] )
+                    self.SetColor(self.Z[i+1,j])
+                    glVertex3f( X_shift[i+1,j], Z_shift[i+1,j],Y_shift[i+1,j] )
+                    self.SetColor(self.Z[i,j+1])
+                    glVertex3f( X_shift[i,j+1], Z_shift[i,j+1],Y_shift[i,j+1])
+                    self.SetColor(self.Z[i+1,j+1])
+                    glVertex3f( X_shift[i+1,j+1], Z_shift[i+1,j+1],Y_shift[i+1,j+1] )
+            glEnd()
+
+            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
+            glEnable(GL_POLYGON_OFFSET_FILL);
+            glPolygonOffset(1.0, 1.0);
+            glColor3f(0.98, 0.98, 0.98)
+            glBegin(GL_TRIANGLES)
+            for i in range(plotsizex-1):
+                for j in range(plotsizey-1):
+                    glVertex3f( X_shift[i,j],Z_shift[i,j],Y_shift[i,j])
+                    glVertex3f( X_shift[i+1,j],Z_shift[i+1,j],Y_shift[i+1,j])
+                    glVertex3f( X_shift[i,j+1], Z_shift[i,j+1],Y_shift[i,j+1] )
+                    glVertex3f( X_shift[i+1,j], Z_shift[i+1,j],Y_shift[i+1,j] )
+                    glVertex3f( X_shift[i,j+1], Z_shift[i,j+1],Y_shift[i,j+1])
+                    glVertex3f( X_shift[i+1,j+1], Z_shift[i+1,j+1],Y_shift[i+1,j+1] )
+            glEnd()
+            glDisable(GL_POLYGON_OFFSET_FILL);
+
+        
+        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
+        glEnable(GL_LIGHTING)
+
+class plot3_points(figure) :
+    &quot;&quot;&quot; class for plotting points in 3d&quot;&quot;&quot;
+    def __init__(self,Points,colors = Colors,linewidth = 0.1,pointsize=5,precision=3,num_ticks=5):
+        self.Colors = colors
+        self.linewidth= linewidth
+        self.pointsize = pointsize
+        self.precision = precision
+        self.num_ticks = num_ticks
+        self.Rescale(Points)
+        self.make_plot(colors)
+        return
+
+    def Rescale(self,Points) :
+	self.xmin = min(Points[:,0])
+        self.xmax = max(Points[:,0])
+        self.ymin = min(Points[:,1])
+        self.ymax = max(Points[:,1])
+        self.zmin = min(Points[:,2])
+        self.zmax = max(Points[:,2])
+
+	#rescaling
+        self.Points = N.array(Points)
+        self.Points[:,0] = (self.Points[:,0]-self.xmin)/abs(self.xmax-self.xmin)
+	self.Points[:,1] = (self.Points[:,1]-self.ymin)/abs(self.ymax-self.ymin)
+	self.Points[:,2] = (self.Points[:,2]-self.zmin)/abs(self.zmax-self.zmin)
+
+    def drawplot(self) :
+        Points = self.Points - 0.5
+	
+        glDisable(GL_LIGHTING)
+        glColor3f(0,0,1.0)
+	glPointSize(self.pointsize)
+	glBegin(GL_POINTS)
+	for i in range(Points.shape[0]) :
+                self.SetColor(Points[i,2])
+		glVertex3f(Points[i,0],Points[i,2],Points[i,1])
+	glEnd()
+        glEnable(GL_LIGHTING)
+    
+class plot3(figure) :
+    &quot;&quot;&quot; similar to matlab plot3 functionality&quot;&quot;&quot;
+    def __init__(self,X,Y,Z,colors = Colors,linewidth = 0.1,precision=3,num_ticks=5):
+        self.Colors = colors
+        self.linewidth= linewidth
+        self.precision = precision
+        self.num_ticks = num_ticks
+        self.Rescale(X,Y,Z)
+        self.make_plot(colors)
+        return
+    
+    def drawplot(self) :
+        glPolygonMode(GL_FRONT_AND_BACK,GL_LINE)
+        glDisable(GL_LIGHTING)
+            
+        glBegin(GL_LINES)
+
+        glColor3f(self.Colors[0,0], self.Colors[0,1], self.Colors[0,2])
+
+        X_shift = self.X-0.5
+        Y_shift = self.Y-0.5
+        Z_shift = self.Z-0.5
+    
+        plotsize = N.size(self.X)
+        plot_range = range(plotsize-1)
+
+        if len(self.X.shape) == 1 :
+            for i in plot_range:
+                glVertex3f( X_shift[i],Z_shift[i],Y_shift[i])
+                glVertex3f( X_shift[i+1],Z_shift[i+1],Y_shift[i+1])        
+
+        else :
+            num_lines = self.X.shape[0]
+            num_points = self.X.shape[1]
+            for i in range(num_lines):
+                self.SetColor(i/(float)(num_lines))
+                for j in range(num_points-1):
+                    glVertex3f( X_shift[i,j],Z_shift[i,j],Y_shift[i,j])
+                    glVertex3f( X_shift[i,j+1],Z_shift[i,j+1],Y_shift[i,j+1])   
+
+        glEnd()
+        glEnable(GL_LIGHTING)
+
+class plotrbf(figure,mesh) :
+    &quot;&quot;&quot;Class written to visualise some radial basis function interpolations &quot;&quot;&quot;
+    def __init__(self,X,Y,Z,Points,colors = Colors,linewidth=0.1,fill_mesh = 0,pointsize=5,precision=3,num_ticks=5):
+        self.Colors = colors
+        self.linewidth= linewidth
+        self.fill_mesh = fill_mesh
+        self.pointsize = pointsize
+        self.precision = precision
+        self.num_ticks = num_ticks
+	self.Rescale(X,Y,Z,Points)
+        self.make_plot(colors)
+        return
+
+    def Rescale(self,X,Y,Z,Points) :
+        figure.Rescale(self,X,Y,Z)
+        self.Points = N.array(Points)
+	#rescaling
+	self.Points[:,0] = (self.Points[:,0]-self.xmin)/abs(self.xmax-self.xmin)
+	self.Points[:,1] = (self.Points[:,1]-self.ymin)/abs(self.ymax-self.ymin)
+	self.Points[:,2] = (self.Points[:,2]-self.zmin)/abs(self.zmax-self.zmin)
+
+        
+    def drawplot(self) :
+        mesh.drawplot(self)
+
+	#rescaling
+	Points = self.Points - 0.5
+	
+        glDisable(GL_LIGHTING)
+        glColor3f(0,0,0)
+	glPointSize(self.pointsize)
+	glBegin(GL_POINTS)
+	for i in range(len(Points[0])) :
+		glVertex3f(Points[i,0],Points[i,2],Points[i,1])
+	glEnd()
+        glEnable(GL_LIGHTING)
+
+        
diff -r 7dceb6835303 -r c1f853495d65 graphics/output.png
Binary file graphics/output.png has changed
diff -r 7dceb6835303 -r c1f853495d65 graphics/outputYZ.png
Binary file graphics/outputYZ.png has changed
diff -r 7dceb6835303 -r c1f853495d65 graphics/raster_map.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graphics/raster_map.py	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,1348 @@
+from Numeric import *
+from string import *
+from visual import *
+from random import uniform, seed
+
+class color_map:
+    '''For contour coloring'''
+    def __init__(self, zmin=-10001.0, zmax=-10000.0, contour_interval=1.0, 
+                                 colmin = vector(0,0,0), colmax=vector(1,1,1), color_scheme=&quot;linear&quot;):
+        self.zmin = zmin
+        self.zmax = zmax
+        self.colmin = colmin
+        self.colmax = colmax
+        self.contour_interval=contour_interval
+        self.color_scheme = color_scheme
+        
+        if self.color_scheme == &quot;linear&quot;:
+            self.set_linear_colors()
+        
+    def set_linear_colors(self):
+        self.colors  = []
+        z = self.zmin
+        while z &lt;= self.zmax:
+            '''interpolate color vectors'''
+            zval = z #(z + z+ self.contour_interval) / 2.0
+            if zval &gt;= self.zmax:
+                self.colors.append(self.colmax)
+            else:
+                vf = ((zval - self.zmin) / float(self.zmax - self.zmin))
+                v1 = self.colmin + ((zval - self.zmin) / float(self.zmax - self.zmin)) * (self.colmax - self.colmin)
+                #v1 = vector(vf * abs(self.colmax.x-self.colmin.x), vf * abs(self.colmax.y-self.colmin.y), vf * abs(self.colmax.z-self.colmin.z))
+                self.colors.append(v1)
+            #print z, self.colors[-1]
+            z += self.contour_interval
+
+    def get_color(self, zval):
+        col_index = int((len(self.colors)-1) * (max(zval,  self.zmin) - self.zmin) / float(self.zmax - self.zmin)) #make sure zval &gt; 0
+        #print &quot;self.zmin&quot;, self.zmin
+        #print &quot;self.zmax&quot;, self.zmax
+        #print &quot;a&quot;, zval, max(zval,  self.zmin), float(self.zmax - self.zmin), col_index, self.colors[min(len(self.colors)-1, col_index)]
+        #col_index = col_index * len(self.colors)
+        #print &quot;b&quot;, col_index
+        return self.colors[min(len(self.colors)-1, col_index)]
+
+
+'''A raster map created with a 2d array'''
+
+
+class raster_map:
+    def __init__(self, data_array, xmin=0.0, ymax=0.0, dx=1, zscale=1.0): #datarr, xmin, ymax, dx, nrows, ncols):
+        '''data_array is a 2d array '''
+        self.data = data_array
+        (self.nrows, self.ncols) = self.data.shape
+        self.xmin = xmin
+        self.ymax = ymax
+        self.dx = dx
+        self.scale = zscale
+        self.color = color_map()
+
+        self.particles = []
+        self.particle_trails = []
+
+        self.default = -99999
+
+        self.imin=0
+        self.imax=self.default
+        self.jmin=0
+        self.jmax=self.default
+
+        self.bimin = 0
+        self.bimax = self.ncols
+        self.bjmin = 0
+        self.bjmax = self.nrows
+
+
+    def get_x(self, c):
+        return self.xmin + c * self.dx
+    def get_y(self, r):
+        return self.ymax - r * self.dx
+    def get_val(self, pos):
+       r, c = self.get_rc(pos)
+       return self.data[r,c]        
+    def get_rc(self, pos):
+        r = int(((self.ymax - pos.y + self.dx/2.0) ) /self.dx ) 
+        c = int(((pos.x - self.xmin + self.dx/2.0) ) /self.dx) 
+        return (r, c)
+
+    def inbounds(self, pos, padding=0.0):
+        '''determine if pos is inside the area of the raster map'''
+##        print &quot;inbounds:&quot;, padding
+##        print &quot;inbounds: &quot;, pos.x, self.xmin, padding
+##        print &quot;inbounds: &quot;, pos.x, self.xmin+(self.ncols-1)*self.dx -padding
+##        print &quot;inbounds: &quot;, pos.y, self.ymax, padding
+##        print &quot;inbounds: &quot;, pos.y, self.ymax-(self.nrows-1)*self.dx+padding
+##        if pos.x &lt; self.xmin+padding:
+##            print &quot;out of bounds xmin&quot;
+##        if pos.x &gt; self.xmin+(self.ncols-1)*self.dx -padding:
+##            print &quot;out of bounds xmax&quot;
+##        if pos.y &gt; self.ymax-padding:
+##            print &quot;out of bounds ymax&quot;
+##        if pos.y &lt; self.ymax-(self.nrows-1)*self.dx+padding:
+##            print &quot;out of bounds ymin&quot;
+        
+        if pos.x &lt; self.xmin+padding or \
+          pos.x &gt; self.xmin+(self.ncols-1)*self.dx -padding or \
+          pos.y &gt; self.ymax-padding or \
+          pos.y &lt; self.ymax-(self.nrows-1)*self.dx+padding:
+            #print &quot;out of bounds&quot;
+            l_in = False
+        else:
+            l_in = True
+        return l_in
+        
+
+    def get_quad_nodes(self, pos):
+        '''returns nodes surrounding pos in the order topleft, bottomleft, topright, bottom right'''
+        (r,c) = self.get_rc(pos)
+        n = []
+            
+        x = self.get_x(c)
+        y = self.get_y(r)
+        if pos.x &gt;= x and pos.y &gt;= y: # upper right quad
+            #print &quot;ur&quot;
+            n.append((r-1, c))
+            n.append((r,c))
+            n.append((r-1, c+1))
+            n.append((r, c+1))
+        elif pos.x &gt;= x and pos.y &lt; y: # lower right quad
+            #print &quot;lr&quot;
+            n.append((r,c))
+            n.append((r+1, c))
+            n.append((r, c+1))
+            n.append((r+1, c+1))
+        elif pos.x &lt; x and pos.y &lt; y: # upper left quad
+            #print &quot;ul&quot;
+            n.append((r-1, c-1))
+            n.append((r, c-1))
+            n.append((r-1, c))
+            n.append((r,c))
+        else: # lower left quad
+            #print &quot;ll&quot;
+            n.append((r, c-1))
+            n.append((r+1, c-1))
+            n.append((r,c))
+            n.append((r+1, c))
+        return n
+            
+    def add_particle(self, pos, radius=None, color=None , l_trail=False, trail_radius=0.0, trail_color=vector(0,0.5,0.5)):
+        if not radius:
+            radius = self.dx/5.0
+        if not color:
+            color = vector(0,0,1)
+            
+        pos.z =  self.interpolate_linear(pos)
+        #print &quot;particle position = &quot;, pos
+        #test = sphere(pos=pos, color=(0,0,1), radius=self.dx)
+        #self.particles.append(sphere(pos=pos, radius=radius, color=color))
+        self.particles.append(particle(pos=pos, radius=radius, color=color,
+                                       l_trail=l_trail, trail_radius=trail_radius, trail_color=trail_color))
+
+    def delete_particle(self, particle_number):
+        self.particles[particle_number].delete_particle()
+        #last_particle = self.particles.pop(particle_number)
+        #if self.particles[particle_number].l_trail:
+        #    self.particles[particle_number].delete_trail()
+        
+        self.last_particle = self.particles.pop(particle_number)
+
+    def delete_all_particles(self):
+        if len(self.particles) &gt; 0:
+            for n, i in enumerate(self.particles):
+                i.delete_particle()
+            for n, i in enumerate(self.particles):
+               last_particle = self.particles.pop(n)
+                
+
+    def add_particles_at_nodes(self, step_skip = 1, l_with_trails=False, l_show_trails=False):
+        for i in range(1, self.nrows-1, step_skip):
+            for j in range(1, self.ncols-1, step_skip):
+                self.add_particle(pos=vector(self.dx*i, -self.dx*j), l_trail=l_with_trails)
+                if l_with_trails and not l_show_trails:
+                    self.particles[-1].hide_trail()
+
+    def particles_show(self):
+        if len(self.particles) &gt; 0:
+            for i in self.particles:
+                i.particle.visible = 1
+                
+    def particles_hide(self):
+        if len(self.particles) &gt; 0:
+            for i in self.particles:
+                i.particle.visible = 0
+                
+
+
+
+    def draw_trails(self, radius=0.0, color=vector(0, 0.5, 0.5)):
+        if len(self.particles) &gt; 0:
+            for i in self.particles:
+                i.create_trail(radius=radius, color=color)
+
+    def trails_show(self):
+        if len(self.particles) &gt; 0:
+            for i in self.particles:
+                i.show_trail()
+                
+    def trails_hide(self):
+        #print &quot;trails hide:&quot;, len(self.particles)
+        #fish = chicken - goats
+        if len(self.particles) &gt; 0:
+            for i in self.particles:
+                i.hide_trail()
+            #fish = chicken +goats
+
+    def reset_trails(self):
+        if len(self.particles) &gt; 0:
+            for i in self.particles:
+                i.delete_trail()
+                
+    def interpolate_linear(self, pos):
+        n = self.get_quad_nodes(pos)
+        #print n
+        (x1, y1, z1) = (self.get_x(n[0][1]), self.get_y(n[0][0]), self.data[n[0][0], n[0][1]])
+        z2 = self.data[n[1][0], n[1][1]]
+        z3 = self.data[n[2][0], n[2][1]]
+        z4 = self.data[n[3][0], n[3][1]]
+        wx = (pos.x - x1) / self.dx
+        wy = (y1 - pos.y) / self.dx
+        zp = (z1 * (1.0-wx) + z3*wx) * (1.0-wy) +  (z2 * (1.0-wx) + z4*wx) * (wy)
+        return zp
+        
+    def interpolate_onarray(self, pos, arry):
+        n = self.get_quad_nodes(pos)
+        (x1, y1, z1) = (self.get_x(n[0][1]), self.get_y(n[0][0]), arry[n[0][0], n[0][1]])
+        z2 = arry[n[1][0], n[1][1]]
+        z3 = arry[n[2][0], n[2][1]]
+        z4 = arry[n[3][0], n[3][1]]
+        wx = (pos.x - x1) / self.dx
+        wy = (y1 - pos.y) / self.dx
+        zp = (z1 * (1.0-wx) + z3*wx) * (1.0-wy) +  (z2 * (1.0-wx) + z4*wx) * (wy)
+        return zp
+
+
+    '''Draw 3d maps as a set of blocks'''
+    def draw_map(self, imin=0, imax=-99999,
+                 jmin=0, jmax=-99999,
+                 scale = 1.0, center = 0,
+                 bzmin = 99999, bzmax = -99999,
+                 col_min = 99999, col_max = -99999,
+                 shade=2, contour_interval = 10.0, color_map=None):
+        ''' draw a specific region of the raster map'''
+        self.scale = scale
+        self.shade = shade
+        self.contour_interval = contour_interval
+
+        if imax == self.default:
+            imax = self.nrows
+        if jmax == self.default:
+            jmax = self.ncols
+        print &quot;drawing map &quot;
+        print &quot;imin, imax &quot;, imin, imax
+        print &quot;jmin, jmax &quot;, jmin, jmax
+
+        #minimum and maximum indicies of boxes
+        self.bimin=imin
+        self.bimax=imax
+        self.bjmin=jmin
+        self.bjmax=jmax
+
+        if bzmin == 99999:
+            self.bzmin = 99999
+            for i in range(self.bimin, self.bimax):
+                for j in range(self.bjmin, self.bjmax):
+                    if self.data[i,j] &lt; self.bzmin:
+                        self.bzmin = self.data[i,j]
+        else:
+            self.bzmin = bzmin
+        if bzmax == -99999:
+            self.bzmax = -99999
+            for i in range(self.bimin, self.bimax):
+                for j in range(self.bjmin, self.bjmax):
+                    if self.data[i,j] &gt; self.bzmax:
+                        self.bzmax = self.data[i,j]
+        else:
+            self.bzmax = bzmax
+        if col_min == 99999:
+            self.bcol_min = self.bzmin #- (self.bzmax-self.bzmin)*0.05
+        else:
+            self.bcol_min = col_min
+        if col_max == -99999:
+            self.bcol_max = self.bzmax
+        else:
+            self.bcol_max = col_max
+
+        if self.bcol_max == self.bcol_min:
+            self.bcol_max += 1
+        print &quot;bzmin, bzmax &quot;, self.bzmin, self.bzmax
+        print &quot;bcol_min, bcol_max&quot;, self.bcol_min, self.bcol_max
+        
+        #tdata = self.data[imin:imax,jmin:jmax]
+
+        '''Set up color scale'''
+        seed(1)
+        if color_map:
+            self.color = color_map
+            self.shade = 3
+        else:
+            if self.shade == 2:
+                self.color_scale = contour_colors(self.bzmin, self.bzmax, self.contour_interval)
+
+        print &quot;shade =&quot;, self.shade
+        #draw in topography
+        #tmax = max(max(tdata))
+        #tmin = min(min(tdata))
+        self.boxes = [] #list of boxes that will be drawn
+        for i in range(self.bimin, self.bimax):
+            for j in range(self.bjmin, self.bjmax):
+                ipos = self.xmin + j* self.dx
+                jpos = self.ymax - i* self.dx
+                kpos = scale * (self.data[i,j] + self.bzmin) / 2.0 
+                #colval = (self.data[i,j] - self.bcol_min) / (self.bcol_max - self.bcol_min)  #greyscale
+                #print &quot; kpos, colval =&quot;,  self.data[i,j], colval 
+                self.boxes.append(box(pos=(ipos,jpos, kpos),
+                                      length = self.dx,
+                                      height = self.dx,
+                                      width = (self.data[i,j] - self.bzmin) * scale))
+                                      #color = (colval,colval,colval)))
+                if color_map:
+                    self.boxes[-1].color = self.color.get_color(self.data[i,j])
+                elif self.shade == 1: #put in a color shade on area
+                    colval = 1.0  #greyscale
+                    self.boxes[-1].color = (colval,colval,colval)
+                elif self.shade == 2:
+                    self.boxes[-1].color = self.color_scale.find_color(self.data[i,j])
+                    
+                    
+        if center == 1:
+            self.scene_center(imin, imax, jmin, jmax)
+
+    def update_draw_map(self, bzmin=99999, bzmax=-99999): #draw change in level of water
+        ct = -1
+        #print self.bimin, self.bimax, self.bjmin, self.bjmax
+
+        if self.shade != 3:
+            '''Reset color scale'''
+            if bzmin == 99999:
+                self.bzmin = 99999
+                for i in range(self.bimin, self.bimax):
+                    for j in range(self.bjmin, self.bjmax):
+                        if self.data[i,j] &lt; self.bzmin:
+                            self.bzmin = self.data[i,j]
+            else:
+                self.bzmin = bzmin
+            if bzmax == -99999:
+                self.bzmax = -99999
+                for i in range(self.bimin, self.bimax):
+                    for j in range(self.bjmin, self.bjmax):
+                        if self.data[i,j] &gt; self.bzmax:
+                            self.bzmax = self.data[i,j]
+            else:
+                self.bzmax = bzmax
+            seed(1)
+            if self.shade == 2:
+                self.color_scale = contour_colors(self.bzmin, self.bzmax, self.contour_interval)
+
+        for i in range(self.bimin,self.bimax):
+            for j in range(self.bjmin,self.bjmax):
+                ct += 1
+                #print self.bcol_min, self.bcol_max, self.data[i,j]
+                self.boxes[ct].pos.z = self.scale * (self.data[i,j] + self.bzmin) / 2.0 
+                self.boxes[ct].width = (self.data[i,j] - self.bzmin) * self.scale
+                if self.shade ==3:
+                    self.boxes[ct].color = self.color.get_color(self.data[i,j])
+                elif self.shade == 2:
+                    self.boxes[ct].color = self.color_scale.find_color(self.data[i,j])
+                else:
+                    colval = (self.data[i,j] - self.bcol_min) / (self.bcol_max - self.bcol_min)
+                    self.boxes[ct].color = vector(colval, colval, colval)
+                 
+    def draw_map_hide(self):
+        for i in boxes:
+            i.visible = 0
+    def draw_map_show(self):
+        for i in boxes:
+            i.visible = 1
+
+    def scene_center(self, imin, imax, jmin, jmax):
+        self.xc = self.xmin + (self.dx * ((jmin+jmax)/2.0))
+        self.yc = self.ymax - (self.dx * ((imin+imax)/2.0))
+        self.zc = self.get_val(vector(self.xc,self.yc,0))
+        print &quot;center&quot;, self.xc, self.yc
+        scene.center = vector(self.xc, self.yc, self.zc)
+
+    def map_stripe(self, nstripes=5):
+        ct=-1
+        dbound = (self.bzmax - self.bzmin) / float(nstripes)
+        seed(1)
+        lay_cols = []
+        for k in range(nstripes):
+            lay_cols.append(vector(uniform(0.0,1.0), uniform(0.0,1.0),uniform(0.0,1.0)))
+        
+        for i in range(self.bimin,self.bimax):
+            for j in range(self.bjmin,self.bjmax):
+                ct += 1
+                self.boxes[ct].color = color.white
+                for k in range(nstripes):
+                    #print i, j, k, self.data[i,j], self.bzmin, (self.bzmin+(float(k+1) * dbound))
+                    if (self.data[i,j] &gt; (self.bzmin+(float(k) * dbound))
+                        and self.data[i,j] &lt;= (self.bzmin+(float(k+1) * dbound)) ):
+                        colval = k % 2
+                        gcol = (k+1)/nstripes
+                        #print k, colval
+                        self.boxes[ct].color = lay_cols[k] #(1-gcol,gcol,1)
+                        break
+
+    def block_contour(self, contour_interval=10.0, contour_color=0):
+        '''contour_interval is the contour interval
+           contour_color = 0: Random colors for the contours
+                         = 1: alternating red and white colours
+                         '''
+        ct = -1
+        lay_cols = []
+        contour_boxes = []
+        zmin = int(self.bzmin/contour_interval) * contour_interval
+        zmax = (int(self.bzmax/contour_interval) + 1) * contour_interval
+        n_intervals = int((zmax - zmin) / contour_interval)
+
+        #choose colors
+        if contour_color == 0:
+            for i in range(n_intervals+1):
+                lay_cols.append(vector(uniform(0.0,1.0), uniform(0.0,1.0),uniform(0.0,1.0)))
+        elif contour_color == 1:
+            for i in range(n_intervals+1):
+                if remainder(i , 2) == 1:
+                    lay_cols.append( vector(1,1,1) )
+                else:
+                    lay_cols.append( vector(1,0,0) )
+            
+#        print &quot;zmin&quot;, zmin, &quot;zmax&quot;, zmax, &quot;n_intervals&quot;, n_intervals
+        
+        for i in range(self.bimin,self.bimax):
+            for j in range(self.bjmin,self.bjmax):
+                ct+=1
+                ht = zmin
+                lay = -1
+                ipos = self.xmin + j* self.dx
+                jpos = self.ymax - i* self.dx
+                while ht &lt; self.data[i,j]:
+                    lay += 1
+                    #print &quot;lay&quot;, lay, &quot;data&quot;, self.data[i,j], &quot;ht&quot;, ht
+                    if (ht + contour_interval) &lt; self.data[i,j]: #add full block
+                        contour_boxes.append(box(pos=(ipos,jpos, self.scale*(ht+(contour_interval/2.0))),
+                                                 length = self.dx,
+                                                 height = self.dx,
+                                                 width = contour_interval * self.scale,
+                                                 color = lay_cols[lay] ))
+                        #print &quot;width&quot;, contour_boxes[-1].width, &quot;midpt&quot;, contour_boxes[-1].pos.z
+                    else:
+                        self.boxes[ct].width = self.scale * (self.data[i,j] - ht)
+                        self.boxes[ct].pos.z = self.scale * (ht + ((self.data[i,j]-ht)/2.0))
+                        self.boxes[ct].color = lay_cols[lay]
+                        #print &quot;width&quot;, self.boxes[ct].width, &quot;midpt&quot;, self.boxes[ct].pos.z
+                    ht += contour_interval
+                        
+
+    def draw_boundary(self, radius=1, center=1):
+        bound = curve(color=color.blue, radius=radius)
+        bound.append(pos=(self.xmin, self.ymax,self.data[0,0]))
+        bound.append(pos=(self.xmin+self.dx*(self.ncols-1), self.ymax,self.data[0,0]))
+        bound.append(pos=(self.xmin+self.dx*(self.ncols-1),
+                          self.ymax-self.dx*(self.nrows-1),self.data[0,0]))
+        bound.append(pos=(self.xmin,
+                          self.ymax-self.dx*(self.nrows-1),self.data[0,0]))
+        bound.append(pos=(self.xmin, self.ymax,self.data[0,0]))
+        if center == 1:
+            self.scene_center(self.bimin, self.bimax, self.bjmin, self.bjmax)
+
+    def line_3d(self, imin=0, imax=-99999, jmin=0, jmax=-99999,
+                             scale=1.0, center=1, color_map=None, radius=None):
+        ''' draw a specific region of the raster map as a wire mesh
+            imin - minimum column value to be drawn
+            imax - maximum column value
+            jmin - miinimum row
+            jmax - maximum row
+            scale - to add a vertical exageration
+            center - to center scene on area drawn if center == 1'''
+        self.scale = scale
+        default_val = -99999
+
+        if radius:
+            self.radius = radius
+        else:
+            self.radius = 0
+
+        if color_map:
+            self.color = color_map
+        elif not self.color:
+            self.color = color_map()
+        
+        if imax == default_val:
+            imax = self.nrows
+        if jmax == default_val:
+            jmax = self.ncols
+        print 
+        #tdata = self.data[imin:imax,jmin:jmax]
+        self.imin=imin
+        self.imax=imax
+        self.jmin=jmin
+        self.jmax=jmax
+        self.lin = []
+        for i in range(imin, imax):
+            self.lin.append(curve(color=(0,1,0), radius = self.radius))
+            for j in range (jmin, jmax):
+                ipos = self.xmin + j* self.dx
+                jpos = self.ymax - i* self.dx
+                kpos = self.data[i,j] 
+                self.lin[-1].append(pos=(ipos,jpos,kpos*scale), color=self.color.get_color(kpos))
+                #print lin.pos[-1]
+        for j in range (jmin, jmax):
+            self.lin.append(curve(color=(0,1,0), radius=self.radius))
+            for i in range(imin, imax):
+                ipos = self.xmin + j* self.dx
+                jpos = self.ymax - i* self.dx
+                kpos = self.data[i,j] 
+                self.lin[-1].append(pos=(ipos,jpos,kpos*scale), color=self.color.get_color(kpos))
+        #center of scene of area
+        #print self.xmin + jmin* self.dx, self.ymax - imax* self.dx
+        if center == 1:
+            self.scene_center(imin, imax, jmin, jmax)
+##        if center == 1:
+##            xc = self.xmin + (self.dx * ((jmin+jmax)/2))
+##            yc = self.ymax - (self.dx * ((imin+imax)/2))
+##            zc = self.get_val(vector(xc,yc,0))
+##            print &quot;center&quot;, xc, yc
+##            scene.center = vector(xc, yc, zc)
+##        print &quot;list lenght = &quot;, len(self.lin)
+
+
+    def update_line_3d(self):
+        n = 0
+        #print &quot;imin, imax&quot;, self.imin, self.imax
+        for i in range(self.imin, self.imax):
+            #lin.append(curve(color=(0,1,0)))
+            c = 0
+            #print &quot;jmin, jmax&quot;, self.jmin, self.jmax
+            for j in range (self.jmin, self.jmax):
+                ipos = self.xmin + j* self.dx
+                jpos = self.ymax - i* self.dx
+                kpos = self.data[i,j]
+                #print n, c, &quot;-&quot;, ipos, jpos, kpos
+                #print self.lin[n].pos[c]
+                self.lin[n].pos[c]=(ipos, jpos, kpos*self.scale)
+                self.lin[n].color[c]=self.color.get_color(kpos)
+                c += 1
+                #print lin.pos[-1]
+            n += 1
+        for j in range (self.jmin, self.jmax):
+            #lin.append(curve(color=(0,1,0)))
+            c=0
+            for i in range(self.imin, self.imax):
+                ipos = self.xmin + j* self.dx
+                jpos = self.ymax - i* self.dx
+                kpos = self.data[i,j] 
+                #print n, c, &quot;-&quot;, ipos, jpos, kpos
+                self.lin[n].pos[c]=(ipos, jpos, kpos*self.scale)
+                self.lin[n].color[c]=self.color.get_color(kpos)
+                c+=1
+            n += 1
+    
+    def line_3d_hide(self):
+        for i in self.lin:
+            i.visible = 0
+    def line_3d_show(self):
+        for i in self.lin:
+            i.visible = 1
+
+    def calc_surface_vectors(self):
+        '''find d(data)/dx and d(data)/dy'''
+        self.vx = 0.0 * ones((self.nrows, self.ncols))
+        self.vy = 0.0 * ones((self.nrows, self.ncols))
+        self.vx[self.bimin+1:self.bimax-1, self.bjmin+1:self.bjmax-1] = \
+                                         -(self.data[self.bimin+1:self.bimax-1, self.bjmin+2:self.bjmax] - \
+                                            self.data[self.bimin+1:self.bimax-1, self.bjmin:self.bjmax-2] ) / (2.0*self.dx)
+        self.vy[self.bimin+1:self.bimax-1, self.bjmin+1:self.bjmax-1]  = \
+                                          (self.data[self.bimin+2:self.bimax, self.bjmin+1:self.bjmax-1] - \
+                                            self.data[self.bimin:self.bimax-2, self.bjmin+1:self.bjmax-1] ) / (2.0*self.dx)
+
+    def draw_vectors(self, vscale=1.0, color_map=None):
+        self.vscale = vscale
+        self.calc_surface_vectors()
+        print self.vx
+        print self.vy
+        self.arrows = []
+        ct = -1
+        for i in range(self.bimin, self.bimax):
+            for j in range(self.bjmin, self.bjmax):
+                ct += 1
+                ipos = self.xmin + j* self.dx
+                jpos = self.ymax - i* self.dx
+                kpos = self.scale * self.data[i,j] 
+                #print i,j
+                
+                self.arrows.append(arrow(pos=(ipos,jpos,kpos),
+                                      axis = (self.vx[i,j]*self.vscale, self.vy[i,j]*self.vscale, 0.0)))
+                if not color_map:
+                    self.arrows[-1].color = color.red
+
+    def vectors_show(self):
+        for i in self.arrows:
+            i.visible = 1
+    def vectors_hide(self):
+        for i in self.arrows:
+            i.visible = 0
+                    
+    def update_vectors(self, l_calc = True):
+        #print &quot;updating vectors&quot;
+        if l_calc:
+            self.calc_surface_vectors()
+        ct = -1
+        for i in range(self.bimin, self.bimax):
+            for j in range(self.bjmin, self.bjmax):
+                ct += 1
+                ipos = self.xmin + j* self.dx
+                jpos = self.ymax - i* self.dx
+                kpos = self.scale * self.data[i,j] 
+                self.arrows[ct].pos = vector(ipos,jpos,kpos)
+                self.arrows[ct].axis = vector(self.vx[i,j]*self.vscale, self.vy[i,j]*self.vscale, 0.0)
+        
+
+    def surface_3d(self, imin=0, imax=-99999, jmin=0, jmax=-99999,
+                                      scale=1.0, center=1, twoSided=True, smooth = False, color_map=None):
+        ''' draw a specific region of the raster map as a wire mesh
+            imin - minimum column value to be drawn
+            imax - maximum column value
+            jmin - miinimum row
+            jmax - maximum row
+            scale - to add a vertical exageration
+            center - to center scene on area drawn if center == 1'''
+        self.scale = scale
+        if color_map:
+            self.color = color_map
+
+        default_val = -99999
+
+        self.smooth = smooth
+        
+        if imax == default_val:
+            imax = self.nrows
+        if jmax == default_val:
+            jmax = self.ncols
+
+        #tdata = self.data[imin:imax,jmin:jmax]
+        self.imin=imin
+        self.imax=imax
+        self.jmin=jmin
+        self.jmax=jmax
+
+        self.surf = surface_model(twoSided=twoSided, color_map = self.color)
+        pt1 = zeros( (3,), Float)
+        pt2 = zeros( (3,), Float)
+        pt3 = zeros( (3,), Float)
+        pt4 = zeros( (3,), Float)
+        ct = 0
+        for i in range(imin, imax-1):
+            for j in range(jmin, jmax-1):
+                pt1[0] = self.xmin + j* self.dx
+                pt2[0] = self.xmin + (j+1)* self.dx
+                pt3[0] = self.xmin + (j+1)* self.dx
+                pt4[0] = self.xmin + j* self.dx
+
+                pt1[1] = self.ymax - i* self.dx
+                pt2[1] = self.ymax - i* self.dx
+                pt3[1] = self.ymax - (i+1)* self.dx
+                pt4[1] = self.ymax - (i+1)* self.dx
+
+                pt1[2] = self.data[i,j] * self.scale
+                pt2[2] = self.data[i,j+1] * self.scale
+                pt3[2] = self.data[i+1,j+1] * self.scale
+                pt4[2] = self.data[i+1,j] * self.scale
+
+                if (pt1[2] &lt;&gt; 0.0 and
+                    pt2[2] &lt;&gt; 0.0 and
+                    pt3[2] &lt;&gt; 0.0 and
+                    pt4[2] &lt;&gt; 0.0):
+                    #color = self.color.get_color
+                    self.surf.FacetedPolygon(pt1, pt2, pt3, pt4)
+                    ct +=1
+                    #print &quot;ct=&quot;, ct
+        if self.smooth == 1:
+            self.surf.DoSmoothShading()
+        if center == 1:
+            self.scene_center(imin, imax, jmin, jmax)
+
+    def update_surface2_3d(self):
+        #tmp = self.surf.model.__copy__()
+        tmp = self.surf.frame.objects[0].__copy__()
+        print tmp
+##
+        for i in self.surf.frame.objects:
+            #print i
+            i.visible = 0
+
+        self.surface_3d()
+ ##       tmp.visible = 0
+        
+    def update_surface_3d(self):        
+       
+        tct = 0
+        pt1 = zeros( (3,), Float)
+        pt2 = zeros( (3,), Float)
+        pt3 = zeros( (3,), Float)
+        pt4 = zeros( (3,), Float)
+        for i in range(self.imin, self.imax-1):
+            for j in range(self.jmin, self.jmax-1):
+                pt1[0] = self.xmin + j* self.dx
+                pt2[0] = self.xmin + (j+1)* self.dx
+                pt3[0] = self.xmin + (j+1)* self.dx
+                pt4[0] = self.xmin + j* self.dx
+
+                pt1[1] = self.ymax - i* self.dx
+                pt2[1] = self.ymax - i* self.dx
+                pt3[1] = self.ymax - (i+1)* self.dx
+                pt4[1] = self.ymax - (i+1)* self.dx
+
+                pt1[2] = self.data[i,j] * self.scale
+                pt2[2] = self.data[i,j+1] * self.scale
+                pt3[2] = self.data[i+1,j+1] * self.scale
+                pt4[2] = self.data[i+1,j] * self.scale
+
+                if (pt1[2] &lt;&gt; 0.0 and
+                    pt2[2] &lt;&gt; 0.0 and
+                    pt3[2] &lt;&gt; 0.0 and
+                    pt4[2] &lt;&gt; 0.0):
+                    tct = self.surf.UpdateFacetedPolygon(tct, pt1, pt2, pt3, pt4)
+                    
+        if self.smooth == 1:
+            self.surf.DoSmoothShading()
+
+##        self.surf.DoSmoothShading()
+##            for i in range(len(self.model.pos)):
+##                #print &quot;pos&quot;, self.model.pos[i]
+##                lay_num = int(( self.model.pos[i][2] - zmin ) / contour_interval)
+##                #print &quot;lay_num&quot;, lay_num
+##                self.model.color[i] = lay_cols[lay_num]
+## 
+
+    def ContourColor(self, contour_color = 0,
+                     contour_interval=10.0, zmin=0.0, zmax=1000.0):
+        self.surf.ColorContour(contour_color,contour_interval*self.scale,
+                               zmin*self.scale, zmax*self.scale)
+
+    def local_3x3(self, pos):
+	#find the local 3x3 matrix of topography around the cell centered at pos
+	r, c = self.get_rc(pos)
+	#print &quot;r,c=&quot;, r, c
+	return self.data[r-1:r+2, c-1:c+2]
+	    
+    def get_slope(self, pos, dir):
+	#the slope given the positon (pos) and direction and the adjacent cells
+        '''WARNING: THIS IS A PROTOTYPE VERSION AND SHOULD BE USED WITH CAUTION'''
+        print &quot;WARNING: THIS IS A PROTOTYPE VERSION (sub_raster_array) AND SHOULD BE USED WITH CAUTION&quot;
+	posz = self.get_val(pos)
+		
+	pnp = pos + (dir*self.dx)
+        pnelev = self.get_val(pnp)
+        slope = (pnelev - posz/self.scale)/(self.dx)
+
+	#print &quot;r,c=&quot;, r, c
+	return slope
+    def sub_raster_array(self, center_pos, cell_range=1):
+        '''to create a sub raster using only cells within 1 cell_range of the
+        center cell'''
+        r, c = self.get_rc(center_pos)
+        xmin = self.get_x(c - cell_range)
+        ymax = self.get_y(r - cell_range)
+        #print center_pos
+        #print &quot;x, y&quot;, self.get_x(c), self.get_y(r)
+        return raster_map(self.local_3x3(center_pos), xmin, ymax, self.dx)
+
+#########################
+    
+'''END OF RASTER_MAP CLASS'''
+
+#########################
+
+            
+class surface_model:
+    def __init__(self, twoSided= True, color_map=None):
+        self.frame = frame()
+        self.model = faces(frame=self.frame)
+        self.twoSided = twoSided  # add every face twice with opposite normals
+        if color_map:
+            self.color = color_map
+        else:
+            self.color = color_map()
+
+    def FacetedTriangle(self, v1, v2, v3, color=color.white):
+        &quot;&quot;&quot;Add a triangle to the model, apply faceted shading automatically&quot;&quot;&quot;
+	v1 = vector(v1)
+	v2 = vector(v2)
+	v3 = vector(v3)
+        try:
+            normal = norm( cross(v2-v1, v3-v1) )
+        except:
+            normal = vector(0,0,0)
+        #print &quot;self.twoSided = &quot;, self.twoSided
+        for v in (v1,v3,v2):
+            self.model.append( pos=v, color=self.color.get_color(v[2]), normal=normal )
+            #print &quot;initial position = &quot;, self.model.pos[-1]
+            #print v
+        if self.twoSided:
+            for v in (v1,v2,v3):
+                self.model.append( pos=v, color=self.color.get_color(v[2]), normal=-normal )
+                #print v
+        #print &quot;done&quot;
+        #rate(1)
+
+    def FacetedPolygon(self, *v):
+        &quot;&quot;&quot;Appends a planar polygon of any number of vertices to the model,
+           applying faceted shading automatically.&quot;&quot;&quot;
+        for t in range(len(v)-2):
+            self.FacetedTriangle( v[0], v[t+1], v[t+2], color )
+
+    def UpdateFacetedTriangle(self, tct, v1, v2, v3, color=color.white):
+        &quot;&quot;&quot;Add a triangle to the model, apply faceted shading automatically&quot;&quot;&quot;
+	v1 = vector(v1)
+	v2 = vector(v2)
+	v3 = vector(v3)
+        try:
+            normal = norm( cross(v2-v1, v3-v1) )
+        except:
+            normal = vector(0,0,0)
+        for v in (v1,v3,v2):
+            #print &quot;tct, old_pos, new_pos&quot;, tct, self.model.pos[tct], v
+            self.model.pos[tct] = v
+            self.model.normal[tct] = normal
+            self.model.color[tct] = self.color.get_color(v[2])
+            #print tct, v
+            tct += 1
+        if self.twoSided:
+            for v in (v1,v2,v3):
+                self.model.pos[tct] = v
+                self.model.normal[tct] = normal
+                self.model.color[tct] = self.color.get_color(v[2])
+                #print tct, v
+                tct += 1
+        #print &quot;done, normal =&quot;, normal
+        return tct
+
+    def UpdateFacetedPolygon(self, tct,  *v):
+        &quot;&quot;&quot;Appends a planar polygon of any number of vertices to the model,
+           applying faceted shading automatically.&quot;&quot;&quot;
+        for t in range(len(v)-2):
+            tct = self.UpdateFacetedTriangle( tct, v[0], v[t+1], v[t+2])
+        return tct
+
+
+    def DoSmoothShading(self):
+        &quot;&quot;&quot;Change a faceted model to smooth shaded, by averaging normals at
+        coinciding vertices.
+        
+        This is a very slow and simple smooth shading
+        implementation which has to figure out the connectivity of the
+        model and does not attempt to detect sharp edges.
+
+        It attempts to work even in two-sided mode where there are two
+        opposite normals at each vertex.  It may fail somehow in pathological
+        cases. &quot;&quot;&quot;
+
+        pos = self.model.pos
+        normal = self.model.normal
+
+        vertex_map = {}  # vertex position -&gt; vertex normal
+        vertex_map_backface = {}
+        for i in range( len(pos) ):
+            tp = tuple(pos[i])
+            old_normal = vertex_map.get( tp, (0,0,0) )
+            if dot(old_normal, normal[i]) &gt;= 0:
+                vertex_map[tp] = normal[i] + old_normal
+            else:
+                vertex_map_backface[tp] = normal[i] + vertex_map_backface.get(tp, (0,0,0))
+
+        for i in range( len(pos) ):
+            tp = tuple(pos[i])
+            if dot(vertex_map[tp], normal[i]) &gt;= 0:
+                normal[i] = vertex_map[tp] and norm( vertex_map[ tp ] )
+            else:
+                normal[i] = vertex_map_backface[tp] and norm(vertex_map_backface[tp] )
+
+    def DrawNormal(self, scale):
+        pos = self.model.pos
+        normal = self.model.normal
+        for i in range(len(pos)):
+            arrow(pos=pos[i], axis=normal[i]*scale)
+
+    def ColorContour(self, contour_color = 0,
+                     contour_interval=10.0, zmin=0.0, zmax=1000.0):
+        ct = -1
+        lay_cols = []
+        zmin = int(zmin/contour_interval) * contour_interval
+        zmax = (int(zmax/contour_interval) + 1) * contour_interval
+        n_intervals = int((zmax - zmin) / contour_interval)
+
+        print &quot;n_intervals&quot;, n_intervals
+        print &quot;zmin, zmax&quot;, zmin, zmax
+        #choose colors
+        if contour_color == 0 or contour_color == 2:  #random colors
+            for i in range(n_intervals+1):
+                lay_cols.append(vector(uniform(0.0,1.0), uniform(0.0,1.0),uniform(0.0,1.0)))
+        elif contour_color == 1: #alternating red and white
+            for i in range(n_intervals+1):
+                if remainder(i , 2) == 1:
+                    lay_cols.append( vector(1,1,1) )
+                else:
+                    lay_cols.append( vector(1,0,0) )
+
+        if contour_color == 0 or contour_color == 1:    #sharp coloring
+            for i in range(len(self.model.pos)):
+                #print &quot;pos&quot;, self.model.pos[i]
+                lay_num = int(( self.model.pos[i][2] - zmin ) / contour_interval)
+                #print &quot;lay_num&quot;, lay_num
+                self.model.color[i] = lay_cols[lay_num]
+        elif contour_color == 2:                                                                                           #smoothe coloring
+            for i in range(len(self.model.pos)):
+                lay_a = int(( self.model.pos[i][2] - zmin ) / contour_interval)
+                wt_a = ( (lay_a * contour_interval + zmin) - self.model.pos[i][2] ) / contour_interval
+                if (lay_a == 1 and wt_a &gt;=0.0)  or (lay_a == n_intervals and wt_a &lt;= 0.0):
+                    out_col = lay_cols[lay_a]
+                elif wt_a &gt;= 0.0:
+                    out_col = ( lay_cols[lay_a] * wt_a ) + ( lay_cols[lay_a - 1] * (1 - wt_a) )
+                else:
+                    out_col = (- lay_cols[lay_a] * wt_a ) + ( lay_cols[lay_a + 1] * (1 + wt_a) )
+                self.model.color[i] = out_col
+                
+    def  import_new_raster(self,rasterfile):
+        (self.data, self.xmin,  self.ymax, self.dx) = read_arcgis_ascii(rasterfile)
+    #return raster_map(arr, xmin, ymax, dx)
+
+                    
+def read_arcgis_ascii(rasterfile):
+    '''Read in an ArcGIS ASCII raster file'''
+    infile = open(rasterfile,&quot;r&quot;)
+    ct = 0
+    line = infile.readline()
+    while line:
+        ct += 1
+        l = split(strip(line))
+        if ct == 1:
+            ncols = int(l[1])
+        if ct == 2:
+            nrows = int(l[1])
+        if ct == 3:
+            xmin = float(l[1])
+        if ct == 4:
+            ymin = float(l[1])
+        if ct == 5:
+            dx = float(l[1])
+        if ct == 6:
+            nodata = l[1]
+            print &quot;nodata&quot;, nodata
+        if ct &gt;= 7:
+            if ct == 7:
+                topo = zeros((nrows*ncols,), Float)
+                t_ct = -1
+            for i in l:
+                t_ct += 1
+                if i == nodata: #set no-data values to zero
+                    topo[t_ct] = 0.0
+                else:
+                    topo[t_ct] = float(i)
+                
+        line = infile.readline()
+
+    infile.close
+    ymax = ymin + (dx * (nrows-1)) # top left corner
+
+    '''datarr is a 2d array '''
+    #self.xmin = xmin
+    #self.ymax = ymax
+    #self.dx = dx
+    #self.nrows = nrows
+    #self.ncols = ncols
+    #self.data = resize(topo, (nrows, ncols))
+    return (resize(topo, (nrows, ncols)), xmin, ymax, dx)
+    #return raster_map(resize(topo, (nrows, ncols)), xmin, ymax, dx)
+
+
+
+
+def raster_import_ryan(rasterfile, dx=1.0):
+    '''THIS FUNCTION READS IN X, Y, DATA text
+       Code to add if using Ryans ASCII conversion (reminder: dx is defaulted to 1)'''
+    infile = open(rasterfile,&quot;r&quot;)
+    old_long = []
+    old_lat = []
+    old_data = []
+    line = infile.readline()
+    l = splitfields(strip(line),&quot;,&quot;)
+    old_long.append(float(l[0]))
+    old_lat.append(float(l[1]))
+    old_data.append(float(l[2]))
+    ct = 0
+    #data[ct] = float(l[2])
+    ncols = 1
+    nrows = 1
+
+    while line:
+        l = splitfields(strip(line),&quot;,&quot;)
+        #print float(l[1]), float(l[2])
+        old_long.append(float(l[0]))
+        old_lat.append(float(l[1]))
+        old_data.append(float(l[2]))
+        #data[ct+1] = float(l[2])
+        
+        line = infile.readline()
+        ct += 1
+        if (old_long[-1] &lt; old_long[-2]):
+            nrows += 1
+
+    ncols = ct/nrows
+    data = zeros((nrows*ncols,), Float)
+    print &quot;length = &quot;, len(old_data), nrows*ncols
+    for i in range (nrows*ncols):
+        data[i] = old_data[i]
+        
+
+    print &quot;rows, columns, number of items &quot;, nrows, ncols, ct
+    xmin = old_long[0]
+    ymax = old_lat[0]
+
+    return raster_map(resize(data, (nrows,ncols)), xmin, ymax, dx)
+
+
+class contour_colors:
+    '''Produces color scale for contouring'''
+
+    def __init__(self, zmin, zmax, dz = 10.0, color_scheme = &quot;random&quot;):
+        '''To set up the colors for contour levels given:
+           - the contour interval of dz
+           - the starting point of zmin
+           - the maximum level of zmax
+           Data is put into the list lay_cols'''
+        self.min = zmin
+        self.dz = dz
+        self.color_scheme = color_scheme
+        self.colors = []
+        z = zmin
+        #print &quot;contour_colors -&gt; z, zmax&quot;, z, zmax
+        if z == zmax:
+            self.colors.append(vector(1,1,1))
+        else:
+            while  z &lt; zmax:
+                if color_scheme == &quot;random&quot;:
+                    self.colors.append(vector(uniform(0.0,1.0), uniform(0.0,1.0),uniform(0.0,1.0)))
+                z += dz
+
+    def find_color(self, val):
+        col_index = int((val - self.min) / self.dz)
+##        print col_index
+##        print self.colors
+##        print self.colors[col_index]
+        return self.colors[col_index]
+
+                
+class vector_field:
+    '''Takes two coincident raster_map's (uraster and vraster) and produces a 2d vector field
+       uses the dimensions from the first raster map entered for plotting,
+       the first raster map MUST have already drawn a map (draw_map)'''
+
+    def __init__(self, uraster, vraster,
+                                 scale = 1.0, offset = 0.0):
+        self.scale = scale
+        self.offset = offset
+        self.uraster = uraster
+        self.vraster = vraster
+
+        '''The vector mask array can be used to draw only selected areas of a set of vectors.'''
+        vector_mask = resize(zeros((self.uraster.nrows*self.uraster.ncols,), Int ), (self.uraster.nrows, self.uraster.ncols))
+                
+    def draw_vectors(self,
+                                            imin=0, imax=-99999,
+                                            jmin=0, jmax=-99999):
+
+        '''define indices for drawing'''
+        self.imin = imin
+        self.jmin = jmin
+        if imax == -99999:
+            self.imax = self.uraster.nrows
+        else:
+            self.imax = imax
+        if jmax == -99999:
+            self.jmax = self.uraster.ncols
+        else:
+            self.jmax = jmax
+
+        print &quot;i, j indicies&quot;
+        print self.imin, self.imax
+        print self.jmin, self.jmax
+
+        self.arrows = []
+        ct = -1
+        for i in range(self.imin, self.imax):
+            for j in range(self.jmin, self.jmax):
+                #print i,j
+                ct += 1
+                self.arrows.append(arrow(pos=self.uraster.boxes[ct].pos,
+                                      axis = (self.uraster.data[i,j]*self.scale, self.vraster.data[i,j]*self.scale, 0.0+self.offset)))
+
+    def draw_povray_vectors(self, export_directory, ini_base_file, pov_base_file, normal_vector = 15, 
+                                            imin=0, imax=-99999,
+                                            jmin=0, jmax=-99999):
+
+        f = open(ini_base_file,&quot;r&quot;)
+        ini_f = f.read()
+        f.close()
+        
+        f = open(pov_base_file,&quot;r&quot;)
+        pov_f = f.read()
+        f.close
+
+        #print ini_f
+ #       print ini_f.find(&quot;&lt;outfile&gt;&quot;)
+        #print ini_f.replace(&quot;&lt;outfile&gt;&quot;, &quot;CHICKEN&quot;)
+        print &quot;xxccx&quot;
+
+##        line = f.readline()
+##        print &quot;xxxx&quot;, line
+##        while line:
+##            print &quot; xxx&quot;, line
+##            print line.find(&quot;&lt;outfile&gt;&quot;)
+##            line = f.readline()
+ 
+##        pov_file = open(pov_base_file, &quot;r&quot;).readline()
+##        pov_out_file = open(&quot;tmp.pov&quot;, &quot;w&quot;)
+##        pov_f = pov_file.read()
+##    
+        '''define indices for drawing'''
+        self.imin = imin
+        self.jmin = jmin
+        if imax == -99999:
+            self.imax = self.uraster.nrows
+        else:
+            self.imax = imax
+        if jmax == -99999:
+            self.jmax = self.uraster.ncols
+        else:
+            self.jmax = jmax
+
+        print &quot;i, j indicies&quot;
+        print self.imin, self.imax
+        print self.jmin, self.jmax
+
+        old_lat = -9999
+        self.arrows = []
+        ct = -1
+        for i in range(self.imin, self.imax):
+           for j in range(self.jmin, self.jmax):
+                #print i,j
+                ct += 1
+                u = self.uraster.data[i,j]
+                v = self.vraster.data[i,j]
+
+                lat = 90 - (i*2.5)
+                lng = j * 2.5
+                print i, j, lat, lng, u, v
+                
+                lat = &quot;%+03.1F&quot; % lat
+                lng = &quot;%+03.1F&quot; % lng
+
+                if lat &lt;&gt; old_lat:
+                    out_dir = export_directory + &quot;/lat&quot; + lat
+                    subprocess.Popen([r&quot;mkdir&quot;, out_dir], stdout=subprocess.PIPE).communicate()[0]
+                    old_lat = lat
+
+                #jucies
+     
+                ini_out_file = open(&quot;tmp.ini&quot;, &quot;w&quot;)
+                pov_out_file = open(&quot;tmp.pov&quot;, &quot;w&quot;)
+
+                #outfile_name = &quot;%+03.1F%+03.1F.png&quot; % (self.uraster.boxes[ct].pos.x, self.uraster.boxes[ct].pos.y)
+                outfile_name = lat + lng + &quot;.png&quot;
+                outfile_name = out_dir + &quot;/&quot; + outfile_name
+                print outfile_name
+                #juices
+
+                
+                ini =  ini_f.replace(&quot;&lt;outfile&gt;&quot;, outfile_name)
+                #ini_f = ini_f.replace(&quot;&lt;oldfile&gt;&quot;, outfile_name)
+                #print ini
+                #print ini_out_file
+                ini_out_file.write(ini)
+                ini_out_file.close()
+
+                out_angle = get_angle_360(u, v)
+
+                
+                out_angle = &quot;%3.2F&quot; % out_angle
+                #print &quot;out_angle = &quot;, out_angle
+                pov = pov_f.replace(&quot;&lt;rotangle&gt;&quot;, out_angle)
+
+                vect_magnitude = hypot(u, v) / normal_vector
+                vect_magnitude = &quot;%3.5F&quot; % vect_magnitude
+                pov = pov.replace(&quot;&lt;vector_magnitude&gt;&quot;, vect_magnitude)
+                
+                pov_out_file.write(pov)
+                pov_out_file.close()
+
+                subprocess.Popen([r&quot;/sw/bin/povray&quot;, &quot;tmp.ini&quot;], stdout=subprocess.PIPE).communicate()[0]
+
+                
+                #juices
+
+                '''modify arrow-basic.pov file'''
+##                self.arrows.append(arrow(pos=self.uraster.boxes[ct].pos,
+##                                      axis = (self.uraster.data[i,j]*self.scale, self.vraster.data[i,j]*self.scale, 0.0+self.offset)))
+
+
+class layer_raster:
+    '''holds top and bottom elevations of a layer as raster_map's
+       takes two inputs, a top and bottom of a layer'''
+    def __init__(self, top, bot):
+        self.top = top
+        self.bot = bot
+        self.color = color_map()
+
+    def draw_layer(self, color_map=None, center=1):
+        '''color_map is a class defined in this file'''
+##        if color == &quot;white&quot;:
+##            self.color = color_map()
+        if color_map:
+            self.color = color_map
+        print self.color.colors
+        self.boxes = [] #list of boxes that will be drawn
+        for i in range(self.top.bimin, self.top.bimax):
+            for j in range(self.top.bjmin, self.top.bjmax):
+                ipos = self.top.xmin + j* self.top.dx
+                jpos = self.top.ymax - i* self.top.dx
+
+                boxtop = self.top.scale * self.top.data[i,j]
+                boxbot = self.top.scale * self.bot.data[i,j]
+                kpos = (boxtop + boxbot) / 2.0 
+                #colval = (self.data[i,j] - self.bcol_min) / (self.bcol_max - self.bcol_min)  #greyscale
+                #print &quot; kpos, colval =&quot;,  self.data[i,j], colval 
+                self.boxes.append(box(pos=(ipos,jpos, kpos),
+                                      length = self.top.dx,
+                                      height = self.top.dx,
+                                      width = (boxtop - boxbot)*self.top.scale,
+                                      color = self.color.get_color(self.top.data[i,j])))
+                #print self.boxes[-1].color
+        if center == 1:
+            self.top.scene_center(self.top.bimin, self.top.bimax, self.top.bjmin, self.top.bjmax)
+
+    def update_layer(self):
+        ct = -1
+        #print self.bimin, self.bimax, self.bjmin, self.bjmax
+
+        #print self.shade
+        for i in range(self.top.bimin,self.top.bimax):
+            for j in range(self.top.bjmin,self.top.bjmax):
+                ct += 1
+                boxtop = self.top.scale * self.top.data[i,j]
+                boxbot = self.top.scale * self.bot.data[i,j]
+                kpos = (boxtop + boxbot) / 2.0 
+                #print self.bcol_min, self.bcol_max, self.data[i,j]
+                self.boxes[ct].pos.z = kpos 
+                self.boxes[ct].width = (boxtop - boxbot)*self.top.scale
+                self.boxes[ct].color = self.color.get_color(self.top.data[i,j])
+
+    def layer_show(self):
+        for i in self.boxes:
+            i.visible = 1
+    def layer_hide(self):
+        for i in self.boxes:
+            i.visible = 0
+
+    def draw_layer_surfaces(self, color_map_top = None, color_map_bot=None):
+        if color_map_top:
+            self.color_top = color_map_top
+        else:
+            self.color_top = color_map()
+        if color_map_bot:
+            self.color_bot = color_map_bot
+        else:
+            self.color_bot = self.color_top
+        self.top.surface_3d(color_map=self.color_top)
+        self.bot.surface_3d(color_map=self.color_bot)
+
+    def update_layer_surfaces(self):            
+        self.top.update_surface_3d()
+        self.bot.update_surface_3d()
+
+class particle:
+    def __init__(self, pos, radius, color, l_trail=False, draw_limit=0.0, trail_radius=0.0, trail_color=vector(0,0.5,0.5)):
+        '''draw_limit is the distance between drawing points on a particle trail'''
+        self.pos = pos
+        self.old_pos = pos
+        self.color = color
+        self.particle = sphere(pos=self.pos, radius=radius, color=self.color)
+        self.l_trail = l_trail
+        self.draw_limit = draw_limit
+        if self.l_trail:
+            self.create_trail(radius=trail_radius, color=trail_color)
+
+    def move_particle(self, new_pos):
+        self.particle.pos = new_pos
+        if self.l_trail:
+            self.add_to_trail()
+
+    def create_trail(self, radius=0.0, color=vector(0, 0.5, 0.5)):
+        self.l_trail = True
+        #print &quot;color=&quot;, color, radius
+        self.trail = curve(  radius=radius)
+        self.trail.append(pos=self.particle.pos, color=color)
+
+    def add_to_trail(self, draw_limit=None):
+        #print &quot;magnitude=&quot;, self.old_pos, self.particle.pos, mag(self.old_pos, self.particle.pos)
+        if draw_limit:
+            self.draw_limit = draw_limit
+        if  mag(self.old_pos - self.particle.pos) &gt;= self.draw_limit:
+            self.trail.append(pos=self.particle.pos)
+            self.old_pos = self.particle.pos
+
+    def show_trail(self):
+        self.trail.visible = 1
+        
+    def hide_trail(self):
+        if self.l_trail:
+            self.trail.visible = 0
+
+    def delete_trail(self):
+        if self.l_trail:
+            self.l_trail = False
+            self.hide_trail()
+            self.trail.pos = []
+
+    def delete_particle(self):
+        self.particle.visible = 0
+        if self.l_trail:
+            self.trail.visible = 0
+        
+        
+
+
+def get_angle_360(u,v):
+    ang = degrees(atan2(v, u))
+    if ang &lt; 0.0:
+        ang = ang + 360
+    return ang
diff -r 7dceb6835303 -r c1f853495d65 graphics/test.txt
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graphics/test.txt	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,2 @@
+10,21,15
+-1,-1,-1
diff -r 7dceb6835303 -r c1f853495d65 graphics/test.txt~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graphics/test.txt~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,1 @@
+10,21,15
diff -r 7dceb6835303 -r c1f853495d65 graphics/tops_graphs.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/graphics/tops_graphs.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,222 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+# filename: tops_graphs.py
+# Copyright 2008 Luca Bianconi&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">lc.bianconi at googlemail.com</A>&gt; and Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Under the GNU GPL 3 License
+
+#from pylab import *
+#from numpy import *
+#import pylab as p
+#import matplotlib.axes3d as p3
+
+#from raster_map import *
+
+#import mat3d as M
+
+from rpy import r
+
+class Graph2D:
+    
+    def __init__(self, pnts = None):
+        
+        self.points = pnts
+        
+    def plot_data(self):
+        
+        pass
+
+
+#class Graph3D:
+
+    #def __init__(self, pnts = None):
+        
+        #self.points = pnts
+        #self.create_grid()
+        #self.set_data()
+        #self.plot_data()
+    
+    #def create_grid(self):
+        
+        #self.X,self.Y = meshgrid((0,20,1),(0,20,1))
+        
+        #self.Z = zeros((len(self.X),len(self.Y)),'Float32')
+        
+    #def set_data(self):
+        
+        #for p in self.points:
+            #x,y,z = p
+            #ix = int(x / 10)
+            #iy = int(y / 10)
+            #self.Z[iy, ix] = z
+
+        
+    #def plot_data(self):
+        
+        #fig = p.figure()
+        #ax = p3.Axes3D(fig)
+        #ax.plot_wireframe(self.X, self.Y, self.Z)
+        #p.show()
+
+
+#class GraphRasterMap:
+    
+    #def __init__(self, pnts = None):
+        
+        #self.points = pnts
+        #self.rmap = raster_import_ryan(self.points)
+        #self.plot_data()
+
+
+
+        
+    #def plot_data(self):
+        
+        #self.rmap.draw_map(imin=0, imax=349, center=1, scale=1)
+        ##self.rmap.line_3d(imin=100, imax=150,              center=1, scale=1)
+
+ 
+class GraphSimple:
+    
+    def __init__(self, pnts = None, outputname = 'previewgraph'):
+        
+        self.outname = outputname
+        self.points = []
+        self.getPoints(pnts)
+        
+        #self.points = pnts
+        self.plotPts()
+
+        
+    def getPoints(self, f):
+        
+        #file= open(f,&quot;r&quot;).readlines()
+        
+        for l in f:#file:
+            
+            self.points.append(self.getXYPoint(l))
+        
+    def getXYPoint(self, line):
+        
+        l = line#.split(&quot;,&quot;)
+        
+        return [l[1],l[2]]
+    
+    def getXYZPoint(self, line):
+        
+        l = line#.split(&quot;,&quot;)
+        
+        return [l[1],l[2],l[3]]
+        
+    def plotPts(self):
+        
+        if len(self.points[0]) &lt; 3:
+            
+            x = [float(x[0]) for x in self.points]
+            y = [float(y[1]) for y in self.points]
+            
+            r.png('output.png')
+    
+            r.plot(x,y, xlab='x', ylab='y', main='TOPS-preview graph')
+            
+        else:
+            
+            x = [float(x[0]) for x in self.points]
+            y = [float(y[1]) for y in self.points]
+            z = [float(z[1]) for z in self.points]
+            
+            r.png(self.outname+'.png')
+    
+            r.plot(x,y, xlab='x', ylab='y', main='TOPS-preview graph')
+            r.lines(x, z, col='red')
+
+
+#class GraphPersonal:
+    
+    #def __init__(self, pnts = None):
+        
+        #self.points = open(pnts).readlines()
+        #self.plot_data()
+        
+    #def plot_data(self):
+        #i=0
+        #for p in self.points:
+            
+            #ps = p.split(&quot;,&quot;)
+            #if len(ps) == 3:
+                #x = ps[0]
+                #x = float(x)
+                #x= (x-450000)/1000
+                
+                #y = ps[1]
+                #y = float(y)
+                #y = (y-205000)/1000
+                
+                #z = ps[2]
+                #z = float(z)
+                #z = (z-62000)/1000
+                
+                #box(pos = (x+i, y+i, z+i), size = (x,y,z), color = color.green)
+                #i = i+1
+
+
+#class Mat3DMap:
+    
+    #def __init__(self, pnts = None):
+
+        #A = array(pnts) 
+        #M.plot3_points(A,precision=1)
+
+
+class GraphTk:
+    
+    def __init__(self, pnts = None, outputname = 'previewgraph'):
+        
+        self.outname = outputname
+        self.points = []
+        self.getPoints(pnts)
+
+        self.plotPts()
+
+        
+    def getPoints(self, f):
+        
+        #file= open(f,&quot;r&quot;).readlines()
+        if f!=None:
+            
+            for l in f:#file:
+                
+                self.points.append(self.getXYPoint(l))
+            
+    def getXYPoint(self, line):
+        
+        l = line#.split(&quot;,&quot;)
+        
+        return [l[1],l[2]]
+    
+    def getXYZPoint(self, line):
+        
+        l = line#.split(&quot;,&quot;)
+        
+        return [l[1],l[2],l[3]]
+        
+    def plot_data(self):
+        
+        pass
+
+
+if __name__ == '__main__':
+    
+    #Graph2D()
+    
+    #Graph3D([(10,10,10),(5,5,5)])
+    
+    #GraphRasterMap(&quot;../leicatest.txt&quot;)
+    #GraphRasterMap(&quot;test.txt&quot;)
+    
+    #Mat3DMap([(10,10,10),(5,5,5)])
+    
+    #GraphSimple(&quot;../leicatest.txt&quot;)
+    
+    #GraphPersonal(&quot;../leicatest.txt&quot;)
+
+    GraphTk()
\ No newline at end of file
diff -r 7dceb6835303 -r c1f853495d65 models/__init__.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/models/__init__.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,4 @@
+#! /usr/bin/env python
+
+__all__ = [&quot;leica_tcr_1205&quot;, &quot;models&quot;, &quot;zeiss_elta_r55&quot;]
+
diff -r 7dceb6835303 -r c1f853495d65 models/generic.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/models/generic.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,185 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+# filename: generic.py
+
+import serial
+
+from time import sleep
+
+class Connector(serial.Serial):
+    def __init__(self, port=None, baudrate=9600, bytesize=8, parity='N',
+                stopbits=1, timeout=None, xonxoff=0, rtscts=0,
+                writeTimeout=None, dsrdtr=None):
+        
+        serial.Serial.__init__(self, port=port, baudrate=baudrate,
+        bytesize=bytesize, parity=parity, stopbits=stopbits, timeout=timeout,
+        xonxoff=xonxoff, rtscts=rtscts, writeTimeout=writeTimeout,
+        dsrdtr=dsrdtr)
+
+    def open_conn(self):
+        self.open()
+    
+    def download(self):
+        '''Download method for user interfaces.
+        
+        First the class must be instantiated, then the port is open and the
+        transfer from the device can start. Once the transfer is finished
+        the user interface should call this method.'''
+        
+        n = self.inWaiting()
+        result = self.read(n)
+    
+        # looks like there is a maximum buffer of 4096 characters, so we have
+        # to wait for a short time and iterate the process until finished
+        
+        sleep(0.1)
+        
+        while self.inWaiting() &gt; 0:
+            result = result + self.read(self.inWaiting())
+            sleep(0.1)
+        
+        self.result = result
+        return self.result
+
+class Point:
+    
+    def __init__(self, p_id, x, y, z, text):
+        
+        self.p_id= p_id
+        self.x=x
+        self.y=y
+        self.z=z
+        self.text=text
+        
+        self.tuplepoint = (self.p_id, self.x, self.y, self.z, self.text)
+        
+        
+    def get_coords(self):
+        
+        coords = {'x': self.x,'y':self.y,'z':self.z}
+        return coords
+    
+    def get_string_of_points(self):
+        
+        string = str(self.p_id)+&quot; &quot;+str(self.x)+&quot; &quot;+str(self.y)+&quot; &quot;+str(self.z)+&quot; &quot;+str(self.text)
+        return string
+    
+    def dump_point(self):
+        
+        print self.p_id,&quot; &quot;,self.x,&quot; &quot;,self.y,&quot; &quot;,self.z,&quot; &quot;,self.text
+    
+    def point_to_tuple(self):
+        tuplepoint = (self.p_id, self.x, self.y, self.z, self.text)
+        return tuplepoint
+    
+    #def SwapXY(self):
+        
+        #temp = self.x
+        #self.x =self.y
+        #self.y=temp
+
+class PointsList:
+    
+    def __init__(self):
+        
+        self.listofpoints = []
+        
+    def add_point(self, p):
+        
+        self.listofpoints.append(p)
+        
+    def add_points(self, lp):
+        
+        self.listofpoints.extend(lp)
+        
+    def pid_is_in_lop(self, aux_p_id):
+        
+        for p in self.listofpoints:
+            
+            if aux_p_id == p.p_id :
+                return True
+        
+        return False
+        
+    def points_number(self):
+        
+        return len(self.listofpoints)
+        
+    def list_to_tuple(self):
+        
+        list_aux=[]
+        for p in self.listofpoints:
+            list_aux.append(p.tuplepoint)
+        return list_aux
+
+#class Data:
+    
+    #def __init__(self):
+        #pass
+        
+    #def data_from_txt_file(self, filepathname):
+        
+        #file = open(filepathname,'r')
+        #self.lines = file.readlines()
+        #file.close()
+
+
+class Parser:
+    '''Parses a *single* string of raw data and turns it to the internal format.
+    
+    This means that if you plan to load data from a file you have to pass
+    the output of open(file).read() to this class.'''
+    ''' WHO THE FUCK ARE THE ARTIC MONKEYS!?!?!?!'''
+    ''' This should be a good reason to use the commented class DATA'''
+    
+    def __init__(self, data, swapXY=False):
+        
+        self.d = data.splitlines()
+        self.points = PointsList()
+        self.swapXY = swapXY
+        
+        self.parse_retrieve_data()
+        
+        if self.points.points_number() &gt; 0:
+            self.t_points = self.points.list_to_tuple()
+        
+    def set_data(self, data):
+        
+        self.d = data
+    
+    def get_data(self):
+        
+        return self.d
+    
+    def parse_retrieve_data(self):
+        
+        valid_lines = filter(self.is_point, self.d)
+        
+        for l in valid_lines:
+
+            self.points.add_point(self.get_point(l))
+            
+    
+    def is_point(self):
+        
+        pass
+    
+    def get_point(self):
+        
+        pass
+    
+    def print_found_points(self):
+        
+        
+        for p in self.points.listofpoints:
+            p.dump_point()
+            
+    def export_points_toTXT(self, filepathname):
+        
+        file = open(filepathname,'w')
+        
+        for p in self.points.listofpoints:
+            
+            file.write(p.get_string_of_points()+&quot;\n&quot;)
+            
+        file.close()
diff -r 7dceb6835303 -r c1f853495d65 models/leica_tcr_1205.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/models/leica_tcr_1205.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,46 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+# filename: prova_leica.py
+# Copyright 2008 Luca Bianconi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">luxetluc at yahoo.it</A>&gt;
+# Copyright 2008 Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Under the GNU GPL 3 License
+
+from generic import *
+
+
+class LeicaTCR1205(TotalStation):
+	
+	def is_point(self,line):
+		
+		tokens = line.split()
+		
+		try:
+			float(tokens[1])
+			float(tokens[2])
+			float(tokens[3])
+		
+		except (ValueError, IndexError):
+			
+			is_point = False
+		
+		else:	
+			#di questo controllo che segue FORSE non gliene frega un beliscimu
+			if tokens[4]==&quot;MEAS&quot;:
+				is_point = True
+			else:
+				is_point = False
+		
+		return is_point
+		
+	def get_point(self,line):
+		
+		tokens = line.split()
+		
+		if len(tokens)&gt; 5:
+			text = str(tokens[5])
+		else:
+			text = &quot;&quot;
+			
+		p = Point(str(tokens[0]), float(tokens[1]), float(tokens[2]), float(tokens[3]), text)
+		
+		return p
diff -r 7dceb6835303 -r c1f853495d65 models/leica_tcr_705.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/models/leica_tcr_705.py	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,54 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+# filename: leica_tcr_705.py
+# Copyright 2009 Luca Bianconi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">luxetluc at yahoo.it</A>&gt;
+# Copyright 2009 Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Under the GNU GPL 3 License
+
+from generic import *
+
+
+class ModelConnector(Connector):
+    def __init__(self, port):
+        Connector.__init__(self, port=port, baudrate=19200)
+
+
+class ModelParser(Parser):
+    
+    def is_point(self,line):
+        
+        tokens = line.split(&quot;,&quot;)
+        is_point = True
+	
+        try:
+
+            float(tokens[1])
+            float(tokens[2])
+            float(tokens[3])
+	    
+	    
+        except (ValueError, IndexError):
+            is_point = False
+	    
+        #else:
+            #di questo controllo che segue FORSE non gliene frega un beliscimu
+            #if tokens[4]==&quot;MEAS&quot;:
+            #    is_point = True
+            #else:
+            #    is_point = False
+        
+        return is_point
+        
+    def get_point(self,line):
+        
+        tokens = line.split(&quot;,&quot;)
+        
+        if len(tokens)&gt; 4:
+            text = str(tokens[4])
+        else:
+            text = &quot;&quot;
+        
+        p = Point(str(tokens[0]), float(tokens[1]), float(tokens[2]), float(tokens[3]), text)
+	
+        return p
+
diff -r 7dceb6835303 -r c1f853495d65 models/leica_tcr_705.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/models/leica_tcr_705.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,54 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+# filename: leica_tcr_705.py
+# Copyright 2009 Luca Bianconi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">luxetluc at yahoo.it</A>&gt;
+# Copyright 2009 Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Under the GNU GPL 3 License
+
+from generic import *
+
+
+class ModelConnector(Connector):
+    def __init__(self, port):
+        Connector.__init__(self, port=port, baudrate=19200)
+
+
+class ModelParser(Parser):
+    
+    def is_point(self,line):
+        
+        tokens = line.split(&quot;,&quot;)
+        is_point = True
+	
+        try:
+
+            float(tokens[1])
+            float(tokens[2])
+            float(tokens[3])
+	    
+	    
+        except (ValueError, IndexError):
+            is_point = False
+	    
+        #else:
+            #di questo controllo che segue FORSE non gliene frega un beliscimu
+            #if tokens[4]==&quot;MEAS&quot;:
+            #    is_point = True
+            #else:
+            #    is_point = False
+        
+        return is_point
+        
+    def get_point(self,line):
+        
+        tokens = line.split(&quot;,&quot;)
+        
+        if len(tokens)&gt; 4:
+            text = str(tokens[4])
+        else:
+            text = &quot;&quot;
+        
+        p = Point(str(tokens[0]), float(tokens[1]), float(tokens[2]), float(tokens[3]), text)
+	p.dump_point()
+        return p
+
diff -r 7dceb6835303 -r c1f853495d65 models/models.py
--- a/models/models.py	Tue Mar 24 09:31:43 2009 +0100
+++ b/models/models.py	Sun Mar 22 13:18:39 2009 +0100
@@ -1,14 +1,15 @@
 #! /usr/bin/env python
 # -*- coding: utf-8 -*-
 # filename: models.py
-# Copyright 2008 Luca Bianconi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">luxetluc at yahoo.it</A>&gt;
-# Copyright 2008 Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Copyright 2009 Luca Bianconi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">luxetluc at yahoo.it</A>&gt;
+# Copyright 2009 Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
 # Under the GNU GPL 3 License
 
 models = {
     'Leica TCR 1205' : 'leica_tcr_1205',
     'Zeiss Elta R55' : 'zeiss_elta_r55',
     'Nikon Npl 350' : 'nikon_npl_350',
+    'Leica TCR 705' : 'leica_tcr_705',
     'Custom' : 'generic'
     }
 
diff -r 7dceb6835303 -r c1f853495d65 models/models.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/models/models.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,20 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+# filename: models.py
+# Copyright 2008 Luca Bianconi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">luxetluc at yahoo.it</A>&gt;
+# Copyright 2008 Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Under the GNU GPL 3 License
+
+models = {
+    'Leica TCR 1205' : 'leica_tcr_1205',
+    'Zeiss Elta R55' : 'zeiss_elta_r55',
+    'Nikon Npl 350' : 'nikon_npl_350',
+    'Custom' : 'generic'
+    }
+
+if __name__ == '__main__':
+    print(&quot;List of supported models:\n------------------------&quot;)
+    for k in models.keys():
+        print k
+    print(&quot;&quot;)
+
diff -r 7dceb6835303 -r c1f853495d65 models/nikon_npl_350.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/models/nikon_npl_350.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,83 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+# filename: nikon_npl_350.py
+# Copyright 2008 Luca Bianconi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">luxetluc at yahoo.it</A>&gt;
+# Copyright 2008 Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Under the GNU GPL 3 License
+
+from generic import *
+
+
+class ModelConnector(Connector):
+    def __init__(self, port):
+        Connector.__init__(self, port=port, bytesize=7)
+
+class ModelParser(Parser):
+    
+    def __init__(self, filename):
+        Parser.__init__(self, filename, swapXY=True)
+    
+    def is_point(self,line):
+
+        is_point = False
+
+        if line.startswith(&quot;SS&quot;):
+            
+            is_point = True
+
+        return is_point
+
+ 
+    def get_point(self,line):
+        #'''Gets a point from a line retrieving basic data.'''
+        line=line.strip(&quot;\r\n&quot;)
+        splittedline = line.split(&quot;,&quot;)
+
+        i=6
+        temptext = &quot;&quot;
+
+        while i&lt; (len(splittedline)):
+
+            
+            if splittedline[i] == &quot;\r&quot;:
+                continue
+            if splittedline[i] == &quot;\n&quot;:
+                continue
+            temptext = temptext+&quot; &quot;+splittedline[i]
+            
+            i = i+1
+        
+        tokens = {
+            'pid' : splittedline[1],
+            'text' : temptext,
+            'x' : splittedline[3],
+            'y' : splittedline[4],
+            'z' : splittedline[5]
+            }
+        
+        point_id = int(tokens['pid'])
+        text = str(tokens['text'])
+        
+        # note that for now we keep floats into strings to avoid approximation
+        # problems, provided that for writing DXF a string is sufficient.
+        # FIXME before introducing new output formats.
+        # We could use string formatting operations to store data as floats
+        # and convert them to strings with the needed precision on the fly.
+        
+        x = float(tokens['x'])
+        y = float(tokens['y'])
+        z = float(tokens['z'])
+        
+        #&quot;&quot;&quot; Even here it would have been better not giving x and y the wrong values(the inverted ones)but directly the right ones! &quot;&quot;&quot;
+        p = Point(point_id, y, x, z, text)
+        #p.dump_point()
+        #&quot;&quot;&quot; Here it's always True so it's not worthy making the machine evaluating the condition. &quot;&quot;&quot;
+        
+        ##if self.swapXY is True:
+            ##p = Point(point_id, y, x, z, text)
+        ##else:
+            ##p = Point(point_id, x, y, z, text)
+        
+        return p
+
+        
diff -r 7dceb6835303 -r c1f853495d65 models/zeiss_elta_r55.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/models/zeiss_elta_r55.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,85 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+# filename: zeiss_elta_r55.py
+# Copyright 2008 Luca Bianconi &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">luxetluc at yahoo.it</A>&gt;
+# Copyright 2008 Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Under the GNU GPL 3 License
+
+from generic import *
+
+
+class ModelConnector(Connector):
+    def __init__(self, port):
+        Connector.__init__(self, port=port, bytesize=7)
+
+class ModelParser(Parser):
+    
+    def __init__(self, filename):
+        Parser.__init__(self, filename, swapXY=True)
+    
+    def is_point(self,line):
+
+        tokens = {
+            'sequence' : line[0:7],
+            'pid' : line[8:27],
+            'text' : line[27:32],
+            'X_str' : line[36],
+            'x' : line[38:50],
+            'Y_str' : line[51],
+            'y' : line[53:66],
+            'Z_str' : line[67],
+            'z' : line[69:80]
+            }
+        
+        try:
+            int(tokens['sequence'])
+            int(tokens['pid'])
+            float(tokens['x'])
+            float(tokens['y'])
+            float(tokens['z'])
+        
+        except (ValueError, IndexError):
+            
+            is_point = False
+        
+        else:
+            
+            is_point = True
+        
+        return is_point
+    
+    def get_point(self,line):
+        '''Gets a point from a line retrieving basic data.'''
+        
+        tokens = {
+            'pid' : line[8:27].strip(),   # the result is more elegant than
+            'text' : line[27:32].strip(), # the code (Heisenberg rocks!)
+            'x' : line[38:50].strip(),
+            'y' : line[53:66].strip(),
+            'z' : line[69:80].strip()
+            }
+        
+        point_id = int(tokens['pid'])
+        text = str(tokens['text'])
+        
+        # note that for now we keep floats into strings to avoid approximation
+        # problems, provided that for writing DXF a string is sufficient.
+        # FIXME before introducing new output formats.
+        # We could use string formatting operations to store data as floats
+        # and convert them to strings with the needed precision on the fly.
+        
+        x = str(tokens['x'])
+        y = str(tokens['y'])
+        z = str(tokens['z'])
+        
+        p = Point(point_id, y, x, z, text)
+        
+        &quot;&quot;&quot; Here it's always True so it's not worthy making the machine evaluating the condition. &quot;&quot;&quot;
+        
+        #if self.swapXY is True:
+            #p = Point(point_id, y, x, z, text)
+        #else:
+            #p = Point(point_id, x, y, z, text)
+        
+        return p
+
diff -r 7dceb6835303 -r c1f853495d65 output/__init__.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/output/__init__.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,4 @@
+#! /usr/bin/env python
+
+__all__ = [&quot;csv&quot;, &quot;dxf&quot;, &quot;dat&quot;]
+
diff -r 7dceb6835303 -r c1f853495d65 output/dat/tops_dat.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/output/dat/tops_dat.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,41 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+# filename: tops_dat.py
+# Copyright 2008 Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Under the GNU GPL 3 License
+
+
+def to_dat(e):
+    if e[4].endswith(&quot;R&quot;):
+        string = &quot;%s %s %s %s\n&quot; % (e[0], e[0], e[1], e[2])
+        return string
+    else:
+        return ''
+
+
+class TotalOpenDAT:
+    
+    &quot;&quot;&quot;
+    Exports points data in DAT format suitable for use with Archis.
+    
+    ``data`` should be an iterable (e.g. list) containing one iterable (e.g.
+    tuple) for each point. The default order is PID, x, x, z, TEXT.
+    
+    This is consistent with our current standard.
+    &quot;&quot;&quot;
+    
+    def __init__(self,data,filepath):
+        output = open(filepath, &quot;wb&quot;)
+        lines = [ to_dat(e) for e in data ]
+        output.writelines(lines)
+        output.close()
+
+
+if __name__ == &quot;__main__&quot;:
+    TotalOpenDAT(
+        [
+            (1,2,3,4,'qwerty'),
+            (&quot;2.3&quot;,42,45,12,'asdfg')
+        ],
+    'tops.dat')
+
diff -r 7dceb6835303 -r c1f853495d65 output/txt/tops_txt.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/output/txt/tops_txt.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,38 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+# filename: tops_csv.py
+# Copyright 2008 Luca Bianconi&lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">lc.bianconi at googlemail.com</A>&gt; and Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Under the GNU GPL 3 License
+
+
+class TotalOpenTXT:
+    
+    &quot;&quot;&quot;
+    Exports points data in TXT format line by line.
+    
+    ``data`` should be an iterable (e.g. list) containing one iterable (e.g.
+    tuple) for each point. The default order is PID, x, y, z, TEXT.
+    
+    This is consistent with our current standard.
+    &quot;&quot;&quot;
+    
+    def __init__(self,data,filepath):
+	
+	file = open(filepath,'w')
+		
+	for d in data:
+		
+                string = &quot;%s,%s,%s\n&quot; % (d[2], d[1], d[3])
+		file.write((str(string)))
+		
+	file.close()
+        
+
+if __name__ == &quot;__main__&quot;:
+    TotalOpenTXT(
+        [
+            (1,2,3,4,'qwerty'),
+            (&quot;2.3&quot;,42,45,12,'asdfg')
+        ],
+    'p.txt')
+
diff -r 7dceb6835303 -r c1f853495d65 sample_data/leica_tcr_705
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sample_data/leica_tcr_705	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,112 @@
+Oxford Archaeology Survey.
+ 
+JOB      SCRAS01
+OPERATOR     MB
+DATE 08/02/05
+INS. NO.    656205
+INS. TYPE.    TCR705
+
+
+SETUP SN      1000
+IH     0.000
+
+Orientation Station          0
+- - - - - - - - - - - - - - - - - - -
+       100,    999.630,   1002.620,     98.406, WALL01 --------
+       101,   1002.825,    999.529,     98.430, WALL01 --------
+       102,   1000.723,    997.323,     98.437, WALL01 --------
+       103,    997.506,   1000.438,     98.402, WALL01 --------
+       104,    998.095,   1001.082,     98.404, WALL01 --------
+       105,    997.298,   1001.882,     98.366, WALL01 --------
+       106,    998.144,   1002.739,     98.361, WALL01 --------
+       107,    998.964,   1001.987,     98.376, WALL01 --------
+      1001,       1.00,       1.00,       1.00, WALL01 --------
+       101,       1.00,       1.00,       1.00, WALL01 --------
+       105,       1.00,       1.00,       1.00, WALL01 --------
+       106,       1.00,       1.00,       1.00, WALL01 --------
+       107,       1.00,       1.00,       1.00, WALL01 --------
+
+SETUP SN      1002
+IH     0.000
+
+Orientation Station        105
+- - - - - - - - - - - - - - - - - - -
+       105,       1.00,       1.00,       1.00, WALL01 --------
+       106,       1.00,       1.00,       1.00, WALL01 --------
+       107,       1.00,       1.00,       1.00, WALL01 --------
+      1001,       1.00,       1.00,       1.00, WALL01 --------
+      1001,       1.00,       1.00,       1.00, WALL01 --------
+       105,       1.00,       1.00,       1.00, WALL01 --------
+       106,       1.00,       1.00,       1.00, WALL01 --------
+       106,       1.00,       1.00,       1.00, WALL01 --------
+       106,       1.00,       1.00,       1.00, WALL01 --------
+       106,       1.00,       1.00,       1.00, WALL01 --------
+       107,       1.00,       1.00,       1.00, WALL01 --------
+
+SETUP SN      1003
+IH     0.000
+
+Orientation Station        105
+- - - - - - - - - - - - - - - - - - -
+       107,       1.00,       1.00,       1.00, WALL01 --------
+       106,       1.00,       1.00,       1.00, WALL01 --------
+       103,       1.00,       1.00,       1.00, WALL01 --------
+       103,       1.00,       1.00,       1.00, WALL01 --------
+       107,       1.00,       1.00,       1.00, WALL01 --------
+      1001,       1.00,       1.00,       1.00, WALL01 --------
+       110,    998.284,   1001.291,     98.372, WALL01 --------
+       111,    997.428,   1002.145,     98.362, WALL01 --------
+       112,    997.428,   1002.145,     98.361, WALL01 --------
+       113,    996.782,   1001.499,     98.399, WALL01 --------
+       114,    993.626,   1004.658,     98.478, WALL01 --------
+       115,    997.102,   1008.034,     98.420, WALL01 --------
+       116,   1000.490,   1004.700,     98.335, WALL01 --------
+       117,    999.403,   1004.069,     98.341, WALL01 --------
+       118,    998.309,   1003.011,     98.356, WALL01 --------
+       119,    999.094,   1002.199,     98.365, WALL01 --------
+       120,   1000.812,    997.443,     98.412, WALL01 --------
+       112,       1.00,       1.00,       1.00, WALL01 --------
+       112,       1.00,       1.00,       1.00, WALL01 --------
+       114,       1.00,       1.00,       1.00, WALL01 --------
+       115,       1.00,       1.00,       1.00, WALL01 --------
+
+SETUP SN      1004
+IH     0.000
+
+Orientation Station        114
+- - - - - - - - - - - - - - - - - - -
+       121,   1000.480,   1004.705,     98.336, WALL03 --------
+       122,   1003.504,   1001.709,     95.307, WALL03 --------
+       123,   1002.440,   1001.125,     95.557, WALL03 --------
+       124,   1002.772,   1000.716,     95.230, WALL03 --------
+       125,    999.646,   1003.845,     98.358, WALL03 --------
+       126,    999.422,   1004.066,     98.357, WALL03 --------
+       127,   1004.293,   1000.955,     95.362, WALL03 --------
+       128,   1001.149,   1004.006,    100.368, WALL03 --------
+       129,   1000.236,   1003.246,    100.270, WALL03 --------
+       130,   1001.070,   1004.095,    100.267, WALL03 --------
+       127,       1.00,       1.00,       1.00, WALL03 --------
+       130,       1.00,       1.00,       1.00, WALL03 --------
+       129,       1.00,       1.00,       1.00, WALL03 --------
+
+SETUP SN      1004
+IH     0.000
+
+Orientation Station        130
+- - - - - - - - - - - - - - - - - - -
+       140,   1000.274,   1003.227,    100.365, WALL04 --------
+       141,   1001.112,   1004.038,    100.342, WALL04 --------
+       142,   1002.522,   1000.962,     96.505, WALL04 --------
+       143,   1003.386,   1001.847,     95.304, WALL04 --------
+       144,   1004.245,   1000.981,     95.842, WALL04 --------
+       145,   1002.963,    999.685,     95.974, WALL04 --------
+       146,   1002.118,   1000.557,     96.021, WALL04 --------
+       147,   1001.995,    998.707,     95.509, WALL04 --------
+       148,   1000.786,    997.542,     95.212, WALL04 --------
+        T1,   1002.324,    998.364,     96.479, WALL04 --------
+        T2,   1003.759,   1000.497,     96.586, WALL04 --------
+        T3,   1001.766,    998.503,     96.475, WALL04 --------
+        T4,   1001.972,    998.705,     96.932, WALL04 --------
+
+File End.
+
diff -r 7dceb6835303 -r c1f853495d65 tkops.py~
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/tkops.py~	Sun Mar 22 13:18:39 2009 +0100
@@ -0,0 +1,706 @@
+#! /usr/bin/env python
+# -*- coding: utf-8 -*-
+# filename: tkops.py
+# Copyright 2009 Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Copyright 2009 Stefano Costa &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">steko at iosa.it</A>&gt;
+# Under the GNU GPL 3 License
+
+import serial
+
+from time import sleep
+from models import models
+
+from Tkinter import *
+from tkMessageBox import showwarning
+import tkSimpleDialog, tkFileDialog
+
+
+def scan():
+    &quot;&quot;&quot;scan for available ports. return a list of tuples (num, name).
+    
+    Part of pySerial (<A HREF="http://pyserial.sf.net">http://pyserial.sf.net</A>)  (C)2002-2003 &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/tops-dev">cliechti at gmx.net</A>&gt;
+    &quot;&quot;&quot;
+    
+    # TODO move this function in a separate module together with scanwin32.py
+    # and add conditional loading depending on the operating system
+    
+    available = []
+    for i in range(256):
+        try:
+            s = serial.Serial(i)
+            available.append( (i, s.portstr))
+            s.close()   #explicit close 'cause of delayed GC in java
+        except serial.SerialException:
+            pass
+    return available
+
+# logo GIF image encoded as base64 string
+# this way we don't need external an external image file
+logo_data = '''
+R0lGODlhMAAwAOfIAC40NjA2NzY6ODw+O0g8MEBBP09JOVRMO1hPP0NDQk9MQVRWVFhaV1tcW2Rn\n
+ZGZpZm1ubHFzbnV3c3h7dnx+ebw/P8wAAM8NDdEGBtQLC9gNDcUcHM4ZGdMTE98XF9MdHd8ZGc8q\n
+KtM3N9Y7O+8pKeM7O/A0NJ1QEbV6MM5cAMFeDdBfBcJfEcVgDc1lDtFgA9xqA9BjCtVoCcNhE8hm\n
+FMVlGtRvHdVyFdJzHeVuAexzAPJ2APV5AfV+CsduJspzLtJ0IMx3M8t4Nd5aWuRJSPFERPFLS+Nc\n
+XNZ7W990dOJjY+hnZ+Jsa/FgYPFsbON0dPV2dvR5eX6AfL2JPPaDDPaFE/eKFPaGGfeNG/iSHd6B\n
+Jd6DKd2FMtyEPMmRPOmNKPeMJO+XLfeSJPiWIfmZJfWULPmbKumQMOmVPveVNfKcM/mfMfmfOvqg\n
+LfqkMvmlO/yuPYCCfc+ESNCFSMmZT9WSXPGgRPerQvuuQvGiSPerSvquSfywQ/yySfemVfinV/ev\n
+U/qsUfuzVPy4VPq1WPy6Xdqhc9yoffmvYvmxZfy+Zfq1avu8beereuiufvu7c/3CbPzDdPzEe/3J\n
+fYOFgYeIg4qNh46RjJCUkLGOjqmsprW1tb66ut+ehe2Hh+2Li/aWlveYmN+wi+Cvh+CwieK3leW9\n
+nPrHgP3Lgv3Oif3Skv3WnenHrenIrv7apvXTrf7fsfLTuv7gtv7iuMHBwcrKytra2u7Vwunazeve\n
+0/Lf0O3h1+3h2PPg0v7t1Pbp3+Xl5ezs7PHl5fHr6/vs7Pnx6vPz8/z38///////////////////\n
+////////////////////////////////////////////////////////////////////////////\n
+////////////////////////////////////////////////////////////////////////////\n
+/////////////////////////////////////////////////////yH5BAEAAP8ALAAAAAAwADAA\n
+AAj+AP8JHEiwoMBYNlIoXJjCRiyDECNKhGjjla+LFx/98WNjoseP/xotlKWqZEkeORim6AKy5cAU\n
+s1ylUKWoZk0eM1OhiqQohUuXMOGkiASnaFGcqo6m8fkTZNATCgIEMDAFDs5UR8swbeoRppcEEyhR\n
+cDDAC05UR8Fs5SoRJgJKDBIssIQJAc5JadeyhQhTQKUEmxpUuiTg7tErevcWhHlgwgIGEKQ8OICT\n
+qNUqiRW/nOWlgARKjgfQ0QrpaI/Mmv8FRUFAKoETC0tbxZma76yjtF8qwo1ac9DZKl8U4l3b4G81\n
+YZIrV2OUR+7iA1fImgXL1SpVqSZFglRoUB8+zl/+QCfoSKV5lY7GRwTAII4mTZciLACgfuIRAPjz\n
+51dSH+ITT05gYMGAA2LQxBFP9EcQMR+AUgIUEDZhhAkklBBFB8QoKNATn4SiARQkhCiiBlEskaCC\n
+DIJihAUgihiiBUVcmGF/TxARCgksuvgiCVGUcGJ9TxCYo45CMqEgKVwwwgOLRhDJAyNckNJfMSxE\n
+gsWSFgxB4AUD8oBFJCwUU18daATCgw4zpIAIFWxakcIMOvAQCBp1qNcLDZFQwYMLpqSQCJtUYJGC\n
+KS7wQAUjNPQynhB5sIGSD6otYsWkgv7jQw48sGGHENC1AoQizrVwS6STWiGGT7e04FwhOLRSXA3+\n
+gIjBAwxzCJTCIljkeqpAc8DAgxh61FDbKFsIwsMOKvxiKyNZNGsGU7+osAMPe2gximbFzEBIFTzI\n
+YMhLj4wh7rMDGSIDD1XsMYOYe9VxxhtnzkBQCo+QYe8aa8HJwxpf1MmWLjQIoief80ZixsFurEUo\n
+Dz3gQYMubAWhhhmPLiZJGxi/odelPIxRRhBcsYJDH6GOOq8kbqSscUGpOufGDaw0VcMbV8Igh3Eo\n
+pyyUQXL4aoUZwrpUyg1uxMvLQMEkncIpbzSNRwpJBzPQLvqacYMoLnVCoBC5/BN10sCkgFZRfKQA\n
+zNdS4/IDgUi49AEIHSQh0NfA1C22UX2YXfdx1wKNkIEHFrQUjAUZiDDM3FHXHfYpqHB3h95nRy2Q\n
+MB0IKLVHwNBiQQWc2IJ04sAcEsNCMRyyt+QC2cLJBhbQAsxHwdhiy+sEoZ20BTjafvlAwMi+e23B\n
+ABNCBhycraFEwdSSiQWZ1PL78Qb1TrtiAQEAOw==\n'''
+
+
+class AboutDialog(tkSimpleDialog.Dialog):
+    def body(self, master):
+        title=&quot;Total Open Station 0.1&quot;
+        message=&quot;&quot;&quot;
+Total Open Station is copyright 2008 Luca Bianconi, Stefano Costa and the IOSA
+project.
+
+<A HREF="http://totalopenstation.sharesource.org/">http://totalopenstation.sharesource.org/</A>
+
+The application logo is copyright 2008 Lapo Calamandrei.&quot;&quot;&quot;
+        
+        self.logo_data = logo_data
+        self.logo = PhotoImage(data = self.logo_data)
+        Label(master, image=self.logo).pack()
+        
+        Label(master, text=title, font=(&quot;Helvetica&quot;, &quot;16&quot;, &quot;bold&quot;)).pack()
+        Label(master, text=message).pack()
+    
+    def buttonbox(self):
+        box = Frame(self)
+        w = Button(box, text=&quot;OK&quot;, width=10, command=self.cancel, default=ACTIVE)
+        w.pack(side=LEFT, padx=5, pady=5)
+        self.bind(&quot;&lt;Return&gt;&quot;, self.cancel)
+        self.bind(&quot;&lt;Escape&gt;&quot;, self.cancel)
+        box.pack()
+
+
+class ConnectDialog(tkSimpleDialog.Dialog):
+    def __init__(self, parent, cs):
+        self.conn_str = cs
+        tkSimpleDialog.Dialog.__init__(self, parent)
+    
+    def body(self, master):
+        title=&quot;waiting for data from device&quot;
+        message1=&quot;Connection initialized with the following parameters:\n&quot;
+        params = &quot;%s\n&quot; %(self.conn_str)
+        message2 = &quot;\nStart the download procedure on the device.\n&quot;
+        message2 = message2 + &quot;Press OK when done.&quot;
+        Label(master, bitmap=&quot;hourglass&quot;).pack()
+        Label(master, text=title, font=(&quot;Helvetica&quot;, &quot;16&quot;, &quot;bold&quot;)).pack()
+        Label(master, text=message1).pack()
+        t = Text(master,
+             width=80)
+        t.insert(END, params)
+        t.pack()
+        Label(master, text=message2, fg=&quot;red&quot;).pack()
+
+
+class ProcessDialog(tkSimpleDialog.Dialog):
+    def __init__(self, parent, data, model):
+        self.data = data
+        self.model = model
+        tkSimpleDialog.Dialog.__init__(self, parent)
+    
+    def body(self, master):
+        title=&quot;Choose output format and destination file&quot;
+        question = &quot;Output format:\n&quot;
+        top_frame = Frame(master)
+        top_frame.pack(side = TOP, padx = 5, pady = 5)
+        bottom_frame = Frame(master)
+        bottom_frame.pack(side = TOP, anchor = S)
+        
+        Label(top_frame, bitmap=&quot;question&quot;).pack(side = TOP, anchor = N)
+        Label(top_frame, text=title).pack(side = TOP, anchor = N)
+        output_frame = Frame(top_frame)
+        input_frame = Frame(top_frame)
+        output_frame.pack(side = LEFT)
+        input_frame.pack(side = LEFT)
+        
+        message1=&quot;Data to be processed:\n&quot;
+        params = &quot;%s\n&quot; %(self.data)
+        
+        Label(input_frame, text='Input model').pack(side = TOP)
+        
+        self.optionMODEL_value = StringVar()
+        self.optionMODEL_value.set(self.model)
+        optionMODEL_entry = Menubutton(input_frame,
+                                        text=&quot;choose a model&quot;,
+                                        textvariable=self.optionMODEL_value,
+                                        relief = RAISED,
+                                        width = 24)
+        optionMODEL_entry.menu = Menu(optionMODEL_entry, tearoff=0)
+        optionMODEL_entry[&quot;menu&quot;] = optionMODEL_entry.menu
+        
+        for k,v in models.models.items():
+            optionMODEL_entry.menu.add_radiobutton(label=k,
+                                                        variable=self.optionMODEL_value,
+                                                        value=k)
+        optionMODEL_entry.pack(side = LEFT, anchor = W)
+        
+        Label(output_frame, text=question).pack()
+        self.output_format = StringVar()
+        for t in ['CSV', 'DAT', 'DXF']:
+            w = Radiobutton(output_frame,
+                            text = t,
+                            value = t,
+                            variable = self.output_format
+                            ).pack()
+        Label(bottom_frame, text=message1).pack()
+        t = Text(bottom_frame,
+             width=80)
+        t.insert(END, params)
+        t.pack()
+
+
+class ErrorDialog(tkSimpleDialog.Dialog):
+    def __init__(self, parent, message):
+        self.message = message
+        tkSimpleDialog.Dialog.__init__(self, parent)
+    
+    def body(self, master):
+        title=&quot;Error&quot;
+        message1=&quot;Connection failed with the following error message:\n&quot;
+        message2 = &quot;\nCheck your connection parameters and try again.\n&quot;
+        Label(master, bitmap=&quot;error&quot;, fg=&quot;red&quot;).pack()
+        Label(master, text=title, font=(&quot;Helvetica&quot;, &quot;16&quot;, &quot;bold&quot;)).pack()
+        Label(master, text=message1).pack()
+        t = Entry(master, width=80)
+        t.insert(END, self.message)
+        t.pack()
+        Label(master, text=message2).pack()
+    
+    def buttonbox(self):
+        box = Frame(self)
+        w = Button(box,
+                   text=&quot;Cancel&quot;,
+                   width=10,
+                   command=self.cancel,
+                   default=ACTIVE)
+        w.pack(side=LEFT, padx=5, pady=5)
+        self.bind(&quot;&lt;Return&gt;&quot;, self.cancel)
+        self.bind(&quot;&lt;Escape&gt;&quot;, self.cancel)
+        box.pack()
+
+
+class Tops:
+    def __init__(self, parent):
+        
+        #Set through a click on a &quot;Preview&quot;'s button, to be implemented yet
+        self.graph_plugin = False
+
+        #--- costanti per il controllo della disposizione
+        #--- dei pulsanti
+        buttons_width = 8
+        imb_buttonx = &quot;2m&quot;
+        imb_buttony = &quot;1m&quot;
+        imb_buttons_framex = &quot;3m&quot;
+        imb_buttons_framey = &quot;2m&quot;
+        imb_int_buttons_framex = &quot;3m&quot;
+        imb_int_buttons_framey = &quot;1m&quot;
+
+        self.myParent = parent
+
+        self.main_frame = Frame(parent) ###
+        self.main_frame.pack(expand = YES, fill = BOTH)
+
+        self.upper_frame = Frame(self.main_frame) ###
+        self.upper_frame.pack(side = TOP, expand = NO, padx = 10,
+                                   pady = 5, ipadx = 5, ipady = 5)
+        
+        self.logo_frame = Frame(self.upper_frame)
+        self.logo_frame.pack(side = LEFT, expand = NO)
+        
+        self.logo_data = logo_data
+        self.logo = PhotoImage(data = self.logo_data)
+        self.logo_canvas = Label(self.logo_frame, image=self.logo)
+        self.logo_canvas.pack(side = LEFT, expand = NO, padx = 5,
+                                   pady = 5)
+
+#        welcome_message = &quot;&quot;&quot;
+#        This program will help you to find the right connection
+#        parameters for your total station device, and after that also
+#        to retrieve data from it.&quot;&quot;&quot;
+#        Label(self.header_frame,
+#          text = welcome_message,
+#          justify = LEFT).pack(side = LEFT, anchor = W)
+
+        self.header_frame = Frame(self.upper_frame)
+        self.header_frame.pack(side = LEFT, expand = NO, pady = 5)
+        
+        self.buttons_frame = Frame(self.header_frame)
+        self.buttons_frame.pack(side = TOP, expand = NO, fill = Y,
+                                  ipadx = 5, ipady = 5)
+        
+        # default control panel
+        self.control_panel0 = Frame(self.header_frame)
+        self.control_panel0.pack(side = TOP, expand = YES, fill = Y, padx = 5, pady = 5)
+        
+        # control panel for custom serial connection
+        self.control_panel = Frame(self.header_frame)
+        
+        # option 1 : serial port
+        self.option1_frame = Frame(self.control_panel0, relief = RIDGE, bd = 1)
+        self.option1_frame.pack(side = TOP)
+        
+        self.option1_label = Label(self.option1_frame,
+                                   text=&quot;Port&quot;,
+                                   width = 25)
+        self.option1_label.pack(side = LEFT)
+        self.option1_value = StringVar()
+
+# Leave this Entry uncommented to enter port as a string, or ...
+#
+        self.option1_entry = Entry(self.option1_frame,
+                                   textvariable=self.option1_value,
+                                   width = 25)
+        
+# ... comment out this Menubutton if you want to use the scan() output
+#
+#        self.option1_entry = Menubutton(self.option1_frame,
+#                                        text=&quot;choose a value&quot;,
+#                                        textvariable=self.option1_value,
+#                                        relief = RAISED,
+#                                        width = 24)
+#        self.option1_entry.menu = Menu( self.option1_entry, tearoff=0 )
+#        self.option1_entry[&quot;menu&quot;] = self.option1_entry.menu
+#        for n,s in scan():
+#            self.option1_entry.menu.add_radiobutton ( label=s,
+#                                           variable=self.option1_value,
+#                                           value = s)
+        
+        self.option1_entry.pack(side = LEFT, anchor = W)
+        
+        # option MODEL substitutes all connection parameters for better
+        # user experience
+        
+        self.optionMODEL_frame = Frame(self.control_panel0, relief = RIDGE, bd = 1)
+        self.optionMODEL_frame.pack(side = TOP)
+        
+        self.optionMODEL_label = Label(self.optionMODEL_frame,
+                                   text=&quot;Total Station&quot;,
+                                   justify = LEFT,
+                                   width = 25)
+        self.optionMODEL_label.pack(side = LEFT, anchor = E)
+        self.optionMODEL_value = StringVar()
+        self.optionMODEL_entry = Menubutton(self.optionMODEL_frame,
+                                        text=&quot;choose a model&quot;,
+                                        textvariable=self.optionMODEL_value,
+                                        relief = RAISED,
+                                        width = 24)
+        self.optionMODEL_entry.menu = Menu( self.optionMODEL_entry, tearoff=0 )
+        self.optionMODEL_entry[&quot;menu&quot;] = self.optionMODEL_entry.menu
+        
+        for k,v in models.models.items():
+            self.optionMODEL_entry.menu.add_radiobutton(label=k,
+                                                        variable=self.optionMODEL_value,
+                                                        value=k,
+                                                        command=self.print_model)
+        self.optionMODEL_entry.pack(side = LEFT, anchor = W)
+        
+        # option 2 : baudrate
+        self.option2_frame = Frame(self.control_panel, relief = RIDGE, bd = 1)
+        self.option2_frame.pack(side = TOP)
+        
+        self.option2_label = Label(self.option2_frame,
+                                   text=&quot;Baudrate&quot;,
+                                   width = 25)
+        self.option2_label.pack(side = LEFT)
+        self.option2_value = IntVar()
+        self.option2_value.set(9600)
+        self.option2_entry = Menubutton(self.option2_frame,
+                                        text=&quot;choose a value&quot;,
+                                        textvariable=self.option2_value,
+                                        relief = RAISED,
+                                        width = 24)
+        self.option2_entry.menu = Menu( self.option2_entry, tearoff=0 )
+        self.option2_entry[&quot;menu&quot;] = self.option2_entry.menu
+        self.option2_entry.menu.add_radiobutton ( label=&quot;9600&quot;,
+                                       variable=self.option2_value,
+                                       value = 9600 )
+        self.option2_entry.menu.add_radiobutton ( label=&quot;4800&quot;,
+                                       variable=self.option2_value,
+                                       value = 4800 )
+        self.option2_entry.pack(side = LEFT, anchor = W)
+        
+        # option 3 : bytesize
+        self.option3_frame = Frame(self.control_panel, relief = RIDGE, bd = 1)
+        self.option3_frame.pack(side = TOP)
+        
+        self.option3_label = Label(self.option3_frame,
+                                   text=&quot;Bytesize&quot;,
+                                   justify = LEFT,
+                                   width = 25)
+        self.option3_label.pack(side = LEFT, anchor = E)
+        self.option3_value = IntVar()
+        self.option3_value.set(8)
+        self.option3_entry = Menubutton(self.option3_frame,
+                                        text=&quot;choose a value&quot;,
+                                        textvariable=self.option3_value,
+                                        relief = RAISED,
+                                        width = 24)
+        self.option3_entry.menu = Menu( self.option3_entry, tearoff=0 )
+        self.option3_entry[&quot;menu&quot;] = self.option3_entry.menu
+        self.option3_entry.menu.add_radiobutton (label=&quot;8&quot;,
+                                                 variable=self.option3_value,
+                                                 value = 8 )
+        self.option3_entry.menu.add_radiobutton (label=&quot;7&quot;,
+                                                 variable=self.option3_value,
+                                                 value = 7 )
+        self.option3_entry.menu.add_radiobutton (label=&quot;6&quot;,
+                                                 variable=self.option3_value,
+                                                 value = 6 )
+        self.option3_entry.menu.add_radiobutton (label=&quot;5&quot;,
+                                                 variable=self.option3_value,
+                                                 value = 5 )
+        self.option3_entry.pack(side = LEFT, anchor = W)
+        
+        # option 4 : parity
+        self.option4_frame = Frame(self.control_panel, relief = RIDGE, bd = 1)
+        self.option4_frame.pack(side = TOP)
+        
+        self.option4_label = Label(self.option4_frame,
+                                   text=&quot;Parity setting&quot;,
+                                   justify = LEFT,
+                                   width = 25)
+        self.option4_label.pack(side = LEFT, anchor = E)
+        self.option4_value = StringVar()
+        self.option4_value.set('N')
+        self.option4_entry = Menubutton(self.option4_frame,
+                                        text=&quot;choose a value&quot;,
+                                        textvariable=self.option4_value,
+                                        relief = RAISED,
+                                        width = 24)
+        self.option4_entry.menu = Menu( self.option4_entry, tearoff=0 )
+        self.option4_entry[&quot;menu&quot;] = self.option4_entry.menu
+        self.option4_entry.menu.add_radiobutton (label=&quot;Even&quot;,
+                                                 variable=self.option4_value,
+                                                 value = &quot;E&quot; )
+        self.option4_entry.menu.add_radiobutton (label=&quot;None&quot;,
+                                                 variable=self.option4_value,
+                                                 value = &quot;N&quot; )
+        self.option4_entry.menu.add_radiobutton (label=&quot;Odd&quot;,
+                                                 variable=self.option4_value,
+                                                 value = &quot;O&quot; )
+        self.option4_entry.pack(side = LEFT, anchor = W)
+        
+        # option 5 : stop bit
+        self.option5_frame = Frame(self.control_panel, relief = RIDGE, bd = 1)
+        self.option5_frame.pack(side = TOP)
+        
+        self.option5_label = Label(self.option5_frame,
+                                   text=&quot;Stop bit&quot;,
+                                   justify = LEFT,
+                                   width = 25)
+        self.option5_label.pack(side = LEFT, anchor = E)
+        self.option5_value = IntVar()
+        self.option5_value.set(1)
+        self.option5_entry = Menubutton(self.option5_frame,
+                                        text=&quot;choose a value&quot;,
+                                        textvariable=self.option5_value,
+                                        relief = RAISED,
+                                        width = 24)
+        self.option5_entry.menu =   Menu ( self.option5_entry, tearoff=0 )
+        self.option5_entry[&quot;menu&quot;]  = self.option5_entry.menu
+        self.option5_entry.menu.add_radiobutton (label=&quot;1&quot;,
+                                                 variable=self.option5_value,
+                                                 value = 1 )
+        self.option5_entry.menu.add_radiobutton (label=&quot;2&quot;,
+                                                 variable=self.option5_value,
+                                                 value = 2 )
+        self.option5_entry.pack(side = LEFT, anchor = W)
+
+#        # option 6 : timeout
+#        self.option6_frame = Frame(self.control_panel, relief = RIDGE, bd = 1)
+#        self.option6_frame.pack(side = TOP)
+#        
+#        self.option6_label = Label(self.option6_frame,
+#                                   text=&quot;Timeout (empty for None)&quot;,
+#                                   justify = LEFT,
+#                                   width = 25)
+#        self.option6_label.pack(side = LEFT, anchor = E)
+#        self.option6_value = StringVar()
+#        self.option6_value.set(&quot;0&quot;) 
+#        self.option6_entry = Entry(self.option6_frame,
+#                                   textvariable=self.option6_value,
+#                                   width = 25)
+#        self.option6_entry.pack(side = LEFT, anchor = W)
+#        
+#        # option 7 : xonxoff
+#        self.option7_frame = Frame(self.control_panel, relief = RIDGE, bd = 1)
+#        self.option7_frame.pack(side = TOP)
+#        
+#        self.option7_label = Label(self.option7_frame,
+#                                   text=&quot;Xon/Xoff flow control&quot;,
+#                                   justify = LEFT,
+#                                   width = 25)
+#        self.option7_label.pack(side = LEFT, anchor = E)
+#        self.option7_value = IntVar()
+#        self.option7_entry = Menubutton(self.option7_frame,
+#                                        text=&quot;choose a value&quot;,
+#                                        textvariable=self.option7_value,
+#                                        relief = RAISED,
+#                                        width = 24)
+#        self.option7_entry.menu =   Menu ( self.option7_entry, tearoff=0 )
+#        self.option7_entry[&quot;menu&quot;]  = self.option7_entry.menu
+#        self.option7_entry.menu.add_radiobutton (label=&quot;Enabled&quot;,
+#                                                 variable=self.option7_value,
+#                                                 value = 1 )
+#        self.option7_entry.menu.add_radiobutton (label=&quot;Disabled&quot;,
+#                                                 variable=self.option7_value,
+#                                                 value = 0 )
+#        self.option7_entry.pack(side = LEFT, anchor = W)
+#        
+#        # option 8: hardware flow control
+#        self.option8_frame = Frame(self.control_panel, relief = RIDGE, bd = 1)
+#        self.option8_frame.pack(side = TOP)
+#        
+#        self.option8_label = Label(self.option8_frame,
+#                                   text=&quot;Hardware flow control&quot;,
+#                                   justify = LEFT,
+#                                   width = 25)
+#        self.option8_label.pack(side = LEFT, anchor = E)
+#        self.option8_value = IntVar()
+#        self.option8_entry = Menubutton(self.option8_frame,
+#                                        text=&quot;choose a value&quot;,
+#                                        textvariable=self.option8_value,
+#                                        relief = RAISED,
+#                                        width = 24)
+#        self.option8_entry.menu =   Menu ( self.option8_entry, tearoff=0 )
+#        self.option8_entry[&quot;menu&quot;]  = self.option8_entry.menu
+#        self.option8_entry.menu.add_radiobutton (label=&quot;Enabled&quot;,
+#                                                 variable=self.option8_value,
+#                                                 value = 1 )
+#        self.option8_entry.menu.add_radiobutton (label=&quot;Disabled&quot;,
+#                                                 variable=self.option8_value,
+#                                                 value = 0 )
+#        self.option8_entry.pack(side = LEFT, anchor = W)
+    
+        # dictionary for passing options to Serial
+        self.options = {'port':(1,'str'),
+                   'baudrate':(2,'int'),
+                   'bytesize':(3,'int'),
+                   'parity':(4,'str'),
+                   'stopbits':(5,'int'),
+                   'timeout':(6,'int'),
+                   'xonxoff':(7,'bool'),
+                   'rtscts':(8,'bool')}
+        
+        # control buttons
+        
+        self.connect_button = Button(self.buttons_frame,
+                                      text = &quot;Connect&quot;,
+                                      background = &quot;green&quot;,
+                                      padx = imb_buttonx, 
+                                      pady = imb_buttony)
+        self.connect_button.pack(side = LEFT, anchor = S)
+        self.connect_button.bind(&quot;&lt;Button-1&gt;&quot;, self.connect_action)
+        self.connect_button.bind(&quot;&lt;Return&gt;&quot;, self.connect_action)
+        
+        self.open_button = Button(self.buttons_frame,
+                                      text = &quot;Open file&quot;,
+                                      padx = imb_buttonx, 
+                                      pady = imb_buttony)
+        self.open_button.pack(side = LEFT, anchor = S)
+        self.open_button.bind(&quot;&lt;Button-1&gt;&quot;, self.open_action)
+        self.open_button.bind(&quot;&lt;Return&gt;&quot;, self.open_action)
+        
+        self.save_button = Button(self.buttons_frame,
+                                      text = &quot;Save raw data&quot;,
+                                      padx = imb_buttonx, 
+                                      pady = imb_buttony)
+        self.save_button.pack(side = LEFT, anchor = S)
+        self.save_button.bind(&quot;&lt;Button-1&gt;&quot;, self.save_action)
+        self.save_button.bind(&quot;&lt;Return&gt;&quot;, self.save_action)
+        
+        self.process_button = Button(self.buttons_frame,
+                                        text = &quot;Process data&quot;,
+                                        background = &quot;cyan&quot;,
+                                        padx = imb_buttonx,
+                                        pady = imb_buttony)
+        self.process_button.pack(side = LEFT, anchor = S)
+        self.process_button.bind(&quot;&lt;Button-1&gt;&quot;, self.process_action)
+        self.process_button.bind(&quot;&lt;Return&gt;&quot;, self.process_action)
+        
+        self.about_button = Button(self.buttons_frame,
+                                      text = &quot;About TOPS&quot;,
+                                      padx = imb_buttonx, 
+                                      pady = imb_buttony)
+        self.about_button.pack(side = LEFT, anchor = S)
+        self.about_button.bind(&quot;&lt;Button-1&gt;&quot;, self.about_action)
+        self.about_button.bind(&quot;&lt;Return&gt;&quot;, self.about_action)
+        
+        self.exit_button = Button(self.buttons_frame,
+                                      text = &quot;Quit&quot;, 
+                                      padx = imb_buttonx, 
+                                      pady = imb_buttony)
+        self.exit_button.pack(side = LEFT, anchor = S)
+        self.exit_button.bind(&quot;&lt;Button-1&gt;&quot;, self.exit_action)
+        self.exit_button.bind(&quot;&lt;Return&gt;&quot;, self.exit_action)
+        
+        # text frame
+        self.text_frame = Frame(self.main_frame)
+        self.text_frame.pack(side = BOTTOM, expand = YES, fill = BOTH)
+        
+        self.text_area = Text(self.text_frame, width = 80)
+        self.text_area.insert(END, &quot;Welcome.\nTurn your device on.&quot;)
+        self.text_area.pack(side = LEFT, expand = YES, fill = Y)
+        
+        self.scrollY = Scrollbar ( self.text_frame, orient=VERTICAL,
+        command=self.text_area.yview )
+        self.text_area['yscrollcommand'] = self.scrollY.set
+        self.scrollY.pack(side = RIGHT,expand = YES, fill = Y, anchor = W)
+        
+    def exit_action(self, event):
+        self.myParent.destroy()
+    
+    def print_model(self):
+        model = self.optionMODEL_value.get()
+        if model != 'Custom':
+            self.control_panel.forget()
+        else:
+            self.control_panel.pack(side = TOP, expand = YES, fill = Y, ipadx = 5, ipady = 5)
+    
+    def connect_action(self, event):
+        
+        try:
+            chosen_model = self.optionMODEL_value.get()
+            chosen_port = self.option1_value.get()
+            
+            if chosen_model == 'Custom':
+                
+                # FIXME : convert this section to the new Connector API.
+                #  No more string construction!
+                
+                cs = &quot;serial.Serial(&quot;
+                
+                for k,v in self.options.items():
+                    print k,v
+                    n, t = v
+                    cs = cs + &quot;%s = &quot; %k
+                    if t == 'str':
+                        cs = cs + &quot;'&quot; + eval(&quot;self.option%s_value.get()&quot; %n) + &quot;'&quot;
+                    elif t == 'int':
+                        try:
+                            int(eval(&quot;self.option%s_value.get()&quot; %n))
+                        except ValueError:
+                            cs = cs + &quot;None&quot;
+                        else:
+                            cs = cs + str(int(eval(&quot;self.option%s_value.get()&quot; %n)))
+                    elif t == 'bool':
+                        cs = cs + str(bool(eval(&quot;self.option%s_value.get()&quot; %n)))
+                    
+                    cs = cs + &quot;, &quot;
+                connection_string = cs[:-2] + &quot;)&quot; # remove last &quot;, &quot;
+                try:
+                    TOPSerial = eval(connection_string)
+                except serial.SerialException, detail:
+                    e = ErrorDialog(self.myParent, detail)
+                else:
+                    TOPSerial.open()
+                    d = ConnectDialog(self.myParent, connection_string)
+                    n = TOPSerial.inWaiting()
+                    result = TOPSerial.read(n)
+                    sleep(0.1)
+                    
+                    # prevent full buffer effect
+                    while TOPSerial.inWaiting() &gt; 0:
+                        result = result + TOPSerial.read(TOPSerial.inWaiting())
+                        sleep(0.1)
+                    
+                    self.replace_text(result)
+            
+            else:
+                module = models.models[chosen_model]
+                exec('from models.%s import ModelConnector' % module)
+                mc = ModelConnector(chosen_port)
+                try:
+                    mc.open()
+                except serial.SerialException, detail:
+                    e = ErrorDialog(self.myParent, detail)
+                else:
+                    d = ConnectDialog(self.myParent, mc)
+                    result = mc.download()
+                    self.replace_text(result)
+        except:
+            showwarning(&quot;No Connection options&quot;,&quot;No connection settings entered!\n&quot;) 
+    
+    def open_action(self, event):
+        try:
+            d = tkFileDialog.askopenfilename()
+            of = open(d, 'r')
+            oc = of.read()
+            self.replace_text(oc)
+        except:
+            pass
+    
+    def process_action(self, event):
+        
+        try:
+            chosen_model = str(self.optionMODEL_value.get())
+            data = self.text_area.get(&quot;1.0&quot;, END)
+            d = ProcessDialog(self.myParent, data, chosen_model)
+            module = models.models[d.optionMODEL_value.get()]
+            ofl, ofp = str(d.output_format.get()).lower(), str(d.output_format.get()).upper()
+            exec('from models.%s import ModelParser' % module)
+            exec('from output.%s.tops_%s import TotalOpen%s as Output' % (ofl, ofl, ofp))
+            parsed_data = ModelParser(data)
+            parsed_points = parsed_data.t_points
+            sd = tkFileDialog.asksaveasfilename(defaultextension = '.%s' % ofl)
+            
+            #Enabled by clicking on a &quot;Preview&quot; button, to be implemented yet
+            #It suggests Tops the user wanna use the graphs' plugin, not in the standard &quot;light&quot; version of TOPS
+            if self.graph_plugin == True:
+                
+                from graphics import tops_graphs
+                
+                tops_graphs.GraphSimple(parsed_points,sd)
+            
+            output = Output(parsed_points, sd)
+        except:
+            showwarning(&quot;No Processing options&quot;,&quot;No processing settings entered!\n&quot;) 
+
+        
+    def save_action(self, event):
+        try:
+            sd = tkFileDialog.asksaveasfilename(defaultextension = '.tops')
+            data = self.text_area.get(&quot;1.0&quot;, END)
+            of = open(sd, 'w')
+            oc = of.write(data)
+        except:
+            pass
+        
+    def about_action(self, event):
+        d = AboutDialog(self.myParent)
+    
+    def replace_text(self, text):
+        self.text_area.delete(&quot;1.0&quot;,END)
+        self.text_area.insert(END,text.replace('\r',''))
+
+
+root = Tk()
+Tops = Tops(root)
+root.title(&quot;Total Open Station&quot;)
+root.mainloop()
+

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000006.html">[tops-dev] [PATCH] Added leica tcr 705 sample data and	parser/exporter
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#7">[ date ]</a>
              <a href="thread.html#7">[ thread ]</a>
              <a href="subject.html#7">[ subject ]</a>
              <a href="author.html#7">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/tops-dev">More information about the tops-dev
mailing list</a><br>
</body></html>
